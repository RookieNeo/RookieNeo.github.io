<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[RookieNeo]]></title>
  <link href="https://rookieneo.github.io/atom.xml" rel="self"/>
  <link href="https://rookieneo.github.io/"/>
  <updated>2017-08-23T13:40:12+08:00</updated>
  <id>https://rookieneo.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[灵活扩展的下拉刷新控件的封装]]></title>
    <link href="https://rookieneo.github.io/15113233292599.html"/>
    <updated>2017-11-22T12:02:09+08:00</updated>
    <id>https://rookieneo.github.io/15113233292599.html</id>
    <content type="html"><![CDATA[
<p><font color=#586E75 size=3 ><br/>
最近开始做新项目,需要在Swift项目中使用下拉刷新控件,之前的项目有用过一起其他的三方库,比如MJRefresh,CRRefresh,但是MJ是OC的,总是感觉一个纯Swift项目用OC的不太爽,CR的库没有升级到Swift4,由于是新项目,直接上的Swift4,也不能用,所以就打算自己封装一个.</p>

<p>其实下拉刷新这种常用的控件Github上有很多都封装的不错,但是在我看来,他们都太重了,大部分功能都是我不需要的,至少现在不需要,所以我打算封装一个简单灵活的(适应现在的需求就可以),易扩展的(未来有新的需求也可以很好的实现).</p>

<p>这篇文章我会先从实现功能的角度实现一个耦合性很强的刷新控件,然后一步步的优化,去依赖,最后形成一个使用起来很方便的下拉刷新控件,最后提出当初我设计的时候的一些疑问,和一些优缺点作为自己以后的思考或和大家一起沟通.</p>

<h4 id="toc_0">一个简单的下拉刷新View</h4>

<p>这是一个UI控件,所以首先我就创建了一个View.并把它添加到一个SrollView上.</p>

<pre><code class="language-Swift">extension UIScrollView {
    var neoRefreshHeader: RefreshView{
        get{
            let view = Bundle.main.loadNibNamed(&quot;RefreshView&quot;, owner: self, options: nil)?.last as! RefreshView
            self.addSubview(view)
            view.snp.makeConstraints { (make) in
                make.left.right.equalTo(self)
                make.bottom.equalTo(self.snp.top)
                make.height.equalTo(60)
            }
            return view
        }
    }
}
</code></pre>

<p>这时候当你的scrollView调用<code>neoRefreshHeader</code>的时候,view就添加到ScrollView上,下拉的时候就能看到了.但现在这个View是一个纯展示的静态的,我们的需求就是要在用户不同的操作下,我们有响应,并且能向业务层回调(进行网络请求等耗时操作).这时候我们就需要做一个总结,总结仅对这个功能来说,用户会有哪些操作,然后对这些操作,做一个抽象,把他的操作,抽象为数据的表现形态.</p>

<blockquote>
<p>这里我想稍微展开一下,就是抽象的这一个过程,自从上学开始,我们就一直没有离开过这个词,只不过小学的老师从来不会和你说这个词,因为说了你也不懂,但是抽象经常会和一个词一起说,那就是建模.维基百科给的解释有点模糊,我更偏向百度百科的解释:建模就是建立模型，就是为了理解事物而对事物做出的一种抽象，是对事物的一种无歧义的书面描述.数学都是从实际的特殊的问题出发,将它抽象,一般化,再去解决实际的问题.</p>

<p>这个世界很多道理都是相通的,社会哲学和自然科学一直也是相辅相成的.说了这么多,就是想表达,很多东西,思想都是一样的.我们今天要做的这一个简单的下拉刷新的封装也是一样,从一个特殊的下拉刷新出发,抽象成一个一般化的控件,并用它来解决各类不同需求的刷新问题.以后我们封装别的控件,做别的框架也可以用这样的思想.当然这只是个人理解.当我瞎扯淡就好~~</p>
</blockquote>

<p>回到之前说的,把用户的操作,抽象成一个数据模型,要想下拉刷新,用户要下拉ScrollView,到一定程度,然后松手,数据刷新.那么其实我们可以把它抽象成三种状态对应一个枚举类型</p>

<pre><code class="language-Swift">enum RefreshStatus : String{
    case pullToRefresh    = &quot;下拉刷新&quot;
    case loading          = &quot;正在加载&quot;
    case releaseToRefresh = &quot;松开刷新&quot;
}
</code></pre>

<p>用户开始拖拽的时候是下拉刷新状态,到一定程度,用户还去拖拽,就变成松开刷新的状态,然后用户松手了,就是正在加载状态,最后加载完毕,回到下拉刷新状态,这样一个闭环.确定了这几个状态,我们需要和用户拖拽距离这个数据做配合来改变状态,然后在根据状态的改变来做出UI不同的展示,响应给用户.这就需要做监听</p>

<pre><code class="language-Swift">    override func willMove(toSuperview newSuperview: UIView?) {
        guard let view = newSuperview as? UIScrollView else{
            return
        }
        scrollView = view
        scrollView?.addObserver(self, forKeyPath: &quot;contentOffset&quot;, options: NSKeyValueObservingOptions.new, context: nil)
        
    }
</code></pre>

<p>当我这个View被添加到ScrollView的时候做监听<code>contentOffset</code>属性</p>

<pre><code class="language-swift">override func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) {
    if let path = keyPath,path == &quot;contentOffset&quot;{
        let contontMaxY = -(pullHeight + (scrollView.contentInset.top))
        let y = scrollView.contentOffset.y
        refreshView?.refreshContentOffset(scrollView.contentOffset)
        //拖拽
        if scrollView.isDragging{
            if y &gt; contontMaxY{
                type = .pullToRefresh
            }else{
                type = .releaseToRefresh
            }
        }else{
        //松手
            if type == .releaseToRefresh{
                self.beginHeaderRefreshing()
            }
        }
    }
}
</code></pre>

<p>根据用户下拉的距离的变化,和手是否在屏幕上在相关的逻辑判断来改变状态.最后就是根据状态来改变UI了,我把它写到了枚举的didset里,来统一管理.</p>

<pre><code class="language-Swift">    var type = RefreshStatus.pullToRefresh{
        didSet{
            titleLabel.text = type.rawValue
        }
    }
</code></pre>

<p>跑起来的效果是<br/>
<img src="media/15113233292599/haha.gif" alt="haha"/><br/>
作为一个第一版的Demo,它是可以接受的.当然我们还需要增加许多方法,比如<code>func beginHeaderRefreshing()</code> <code>func endHeaderRefreshing()</code></p>

<h4 id="toc_1">单一职责,功能拆分,易扩展,去依赖</h4>

<p>首先第一点单一职责.这个RefreshView它现在做了好多事,监听用户的滑动手势是它在做,UI的动态更新给用户反馈也是它在做,它一个View做了两件事,这显然没有做到单一职责.我们需要把这个监听放到manager里,让manager去管理view,用户的操作会改变manager里的枚举状态,manager的每当状态改变的时候都会通知view,嘿~哥们,你该变成xxx状态的样子了.然后view改变.这样,我们做到了单一职责,功能也拆分的很明确.<br/>
这时候我们在ScrollView中,添加的get方法就不能返回View了,而是Manager,Manager中实现<code>RefreshControl</code>这个协议</p>

<pre><code class="language-Swift">protocol RefreshControl{
    func beginHeaderRefreshing()
    func endHeaderRefreshing()
    func addPullRefresh(_ refreshView : RefreshStatusChangeProtocol &amp; UIView,_ action: @escaping (() -&gt;Void))
}
</code></pre>

<p>在<code>addPullRefresh</code>的时候创建Manager</p>

<pre><code class="language-Swift">func addPullRefresh(_ refreshView: UIView &amp; RefreshStatusChangeProtocol = RefreshViewConfig.share.defaultView, _ action: @escaping (() -&gt; Void)) {
        for subView in scroll.subviews{
            if let refreshView = subView as? (UIView &amp; RefreshStatusChangeProtocol){
                refreshView.removeFromSuperview()
            }
        }
        let refreshViewManager = RefreshViewManager(scrollView: scroll)
        refreshViewMaker.addPullRefresh(refreshView, action)    
    }
</code></pre>

<p>为了防止重复添加,每次添加的时候都遍历一遍ScrollView,将重复的删掉[1].然后创建Manager,并将负责展示的View传到manager中去,</p>

<pre><code class="language-Swift">func addPullRefresh( _ refreshView: (UIView &amp; RefreshStatusChangeProtocol), _ action: @escaping (() -&gt;Void)){
        self.action = action
        self.refreshView = refreshView
        self.scrollView.addSubview(refreshView)
        self.snp.make{make in
            xxxxxxxx
        }
    }
</code></pre>

<p>在Manager中 将view添加在ScrollView上.</p>

<pre><code class="language-Swift">init(scrollView : UIScrollView) {
    super.init(frame: CGRect(x: 0, y: 0, width: 0, height: 0))
    self.scrollView = scrollView
    self.scrollView.addObserver(self, forKeyPath: &quot;contentOffset&quot;, options: NSKeyValueObservingOptions.new, context: nil)
}
</code></pre>

<p>并在manger的init方法里,对scrollView.contentOffset做监听.</p>

<pre><code class="language-Swift">extension UIScrollView{
    var pd : RefreshControl
    {
        return RefreshViewManager(scroll: self)
    }
}
</code></pre>

<p>这时ScrollView的扩展应该改为这个样子了,每次调用pd,都会返回RefreshControl这些协议类型,业务层也可以调用到声明的三个方法.这样做的目的是为什么?为什么不直接返回直接返回Manager?这样可以大大减少业务端使用的难度,也是为了更加的安全,返回给外层的,就仅仅是一个协议类型,没有任何多余的function.<br/>
Manager的工作完成了我们在来看看RefreshView</p>

<pre><code class="language-Swift">///只可以UIView来实现
protocol RefreshStatusChangeProtocol where Self : UIView {
    func refreshStatusChange(type : RefreshStatus)
    func refreshContentOffset(_ contentOffset: CGPoint)
     var refreshViewManager: RefreshControl? {
        get
        set
    }
}
</code></pre>

<p>RefreshView要做的事很简单,就是实现这个协议,下拉Status发生改变的时候manger会调用<code>refreshStatusChange(type : RefreshStatus)</code>,要是有特殊的需要,就实现<code>refreshContentOffset(_ contentOffset: CGPoint)</code>,至于那个get set的属性,我们暂时先不说.<br/>
这样,我们对这个控件做了一次优化,让我们跑起来看一下效果.但是结果是悲哀的,那就是崩溃了.这个问题,困惑了我很久,报的错误是监听的对象已经不在了.后来我发现,Manager被释放了,所以监听的位置崩溃了.</p>

<p>在ScrollView的扩展当中,每次都会返回一个新的Manager,也就是说每次业务层在调用<code>scrollView.pd.addPullRefresh(_ refreshView : RefreshStatusChangeProtocol &amp; UIView,_ action: @escaping (() -&gt;Void))</code>之后,manager就已经被释放了,而manger中却在监听ScrollView的滑动,所以crash了.但是下拉刷新的View却不会释放,因为它添加到ScrollView上,被ScrollView持有了.这就非常尴尬了,我们把功能拆分了,但是manager又是一个很尴尬的存在,因为谁都不想要它.扩展中只能添加计算属性,不能添加存储属性,所以每次get方法调用完之后,都会被释放.这里我有两种方法,一个是把manager也变成一个View 添加到ScrollView当中,成为下拉刷新View的父View.第二种,把让RefreshView持有manager.这样refreshView不释放,那manager也不会释放.他们的生命周期是一样的.最后我选了第二种.这就是<code>RefreshStatusChangeProtocol</code>增了的那个属性的原因.用它来持有manager,这样就不会释放了.(这个权衡要放在后面讨论)<br/>
还有最后一步,那就是去依赖,一个好的第三方库,肯定是依赖越少越好,我们在这里用了Snapkit,我们换成系统的autolayout</p>

<pre><code class="language-Swift">refreshView.translatesAutoresizingMaskIntoConstraints = false
self.scrollView.addSubview(refreshView)
self.scrollView.addConstraint(NSLayoutConstraint(item: refreshView, attribute: NSLayoutAttribute.left, relatedBy: NSLayoutRelation.equal, toItem: scrollView, attribute: NSLayoutAttribute.left, multiplier: 1, constant: 0))
self.scrollView.addConstraint(NSLayoutConstraint(item: refreshView, attribute: NSLayoutAttribute.right, relatedBy: NSLayoutRelation.equal, toItem: scrollView, attribute: NSLayoutAttribute.right, multiplier: 1, constant: 0))
self.scrollView.addConstraint(NSLayoutConstraint(item: refreshView, attribute: NSLayoutAttribute.bottom, relatedBy: NSLayoutRelation.equal, toItem: scrollView, attribute: NSLayoutAttribute.top, multiplier: 1, constant: 0))
refreshView.addConstraint(NSLayoutConstraint(item: refreshView, attribute: NSLayoutAttribute.height, relatedBy: NSLayoutRelation.equal, toItem: nil, attribute: NSLayoutAttribute.height, multiplier: 1, constant: pullHeight))
</code></pre>

<p>这样一来,这次优化算是完成了.核心功能完成后,那就是锦上添花了,就是定义几个不同样式的RefreshView,给大家提供使用.但这个时候,又一个问题就被抛出来了,你定义了那么多RefreshView,每个都有不用的下拉刷新效果,那你准备怎么让业务端使用这些View呢.</p>

<pre><code class="language-Swift">scrollView.pd.addPullRefresh(RefreshView()) {
    DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 2, execute: {
        self.scrollView.pd.endHeaderRefreshing()
    })
}
</code></pre>

<p>在没有优化之前,我们是这样调用的.我们必须传一个View和一个action,这个action属性很有必要,因为每个ScrollView刷下要执行的业务都是不一样的,但是这个View就不是很有必要了,一个App大部分的刷新样式都是一样的,我们每次添加下拉刷新都需要传一个View,这显然很麻烦,所以我决定加一个默认值,这样当使用默认的View的时候就可以不用传了,由于协议类型不可以有默认是方法,所以我就又做了一个Struct,来实现默认值.然后,又做了一个config.swift,可以配置默认的View和下拉的高度.这里就不在细说.可以clone下代码看下.嘻嘻<br/>
下面我们开始定义不同样式的刷新.</p>

<pre><code class="language-Swift">class RefreshViewConfig {
    static let share = RefreshViewConfig()
    var defaultView: (UIView&amp;RefreshStatusChangeProtocol) {
        get{
            return CustomAnimateRefreshView()
        }
    }
    var defaultPullHeight: CGFloat = 60
}
</code></pre>

<h4 id="toc_2">带有不同动画的RefreshView</h4>

<ul>
<li> 普通的下拉刷新(类似新浪微博)</li>
</ul>

<p><img src="media/15113233292599/sina.gif" alt="sina"/></p>

<p>经过我们对功能的拆分,它的代码简单至极,实现这样的效果,仅仅需要40行代码.</p>

<pre><code class="language-Swift">class NormalRefreshView: UIView,RefreshStatusChangeProtocol {
    var refreViewMake: RefreshControl?
    @IBOutlet weak var refreshImage: UIImageView!
    @IBOutlet weak var activityIndicatorView: UIActivityIndicatorView!
    @IBOutlet private weak var titleLabel: UILabel!
    func refreshStatusChange(type: RefreshStatus) {
        switch type {
        case .loading:
            titleLabel.text = &quot;正在加载&quot;
            refreshImage.isHidden = true
            activityIndicatorView.startAnimating()
        case .pullToRefresh:
            refreshImage.isHidden = false
            titleLabel.text = &quot;下拉刷新&quot;
            activityIndicatorView.stopAnimating()
                self.refreshImage.transform = self.refreshImage.transform.rotated(by: CGFloat.pi)
        case .releaseToRefresh:
            refreshImage.isHidden = false
            titleLabel.text = &quot;松开刷新&quot;
            activityIndicatorView.stopAnimating()
            UIView.animate(withDuration: 0.2, animations: {
                self.refreshImage.transform = self.refreshImage.transform.rotated(by: CGFloat.pi)
            })
        }
    }
    class func getXibView() -&gt; NormalRefreshView{
        let view = Bundle.main.loadNibNamed(&quot;NormalRefreshView&quot;, owner: self, options: nil)?.last as! NormalRefreshView
        return view
    }
    func refreshContentOffset(_ contentOffset: CGPoint) {
    }
}
</code></pre>

<ul>
<li> 简单动效的刷新</li>
</ul>

<p><img src="media/15113233292599/cycle.gif" alt="cycle"/><br/>
它的代码不需要很多,100多行足矣,使用<code>UIBezierPath</code>,<code>CAShapeLayer</code>,<code>CAKeyframeAnimation</code>,<code>CAAnimationGroup</code>配合起来使用,就可以了~但我对效果还是有点不太满意,还需要优化.</p>

<h4 id="toc_3">总结</h4>

<p>到这里,一个下拉刷新的控件就封装完了,下面我要提出一些疑问.</p>

<p>最大的疑问就是在功能拆分的时候manger被释放的问题,我当时提出的两种方案,一种View嵌套的模式,由父view监听用户的动作,子view展示.第二种是将由view引用manger.当时我选择了第二种,我也很难说服自己用哪个好,因为我觉得用哪个都不好.所以这个疑问就放到了最后.</p>

<p>说一下继承,当这篇博客要写完的时候,我在发现了我当初那个问题的答案,至少我心里是满意的答案,就是继承,可能现在提出继承大家会不屑一顾,在这个面向协议,面向切面横行的年代,提出继承未免有点过时了.也正因为我的这个思想导致我一开始设计的时候就总想着面向协议,现在回头想一想,那个manger没有引用,被释放了,其实也说明它是个累赘,或者说它是多余的,但是我们的功能还必须要拆分,这时候我就应该想到继承了,basicView里的私有方法监听,并调用public的方法,public function 负责的实现由继承basicView的View自己来override,子View只在乎动画的效果.</p>

<p>继承确实会有很多问题,比如经典的菱形问题,也有很多诟病,但是任何一种思想,一种设计模式,存在就一定是有意义,它们都各有优缺点,这世界本就没有完美的事物,我们在使用的时候需要权衡利弊选择最合适的.<br/>
</font></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对Swift写时复制技术的理解]]></title>
    <link href="https://rookieneo.github.io/15034498083541.html"/>
    <updated>2017-08-23T08:56:48+08:00</updated>
    <id>https://rookieneo.github.io/15034498083541.html</id>
    <content type="html"><![CDATA[
<p><font color=#5F9EA0 size=3 ></p>

<blockquote>
<p>最近又重新在研究数据结构(<del>当然大学时候学的也不咋地</del>😜)打算把一些经典的数据结构用Swift语言重新实现一遍.虽然在实际开发中,很多高级的数据结构,算法都不需要你来写,我相信每一种语言,都有足够多的框架提供近乎完美的API供你日常开发,这会造成一种幻觉,就是你会觉的这些基础的东西不重要,我理不理解它并不会对我有太大影响,我会调用几个API就足矣.但作为一个coder(其实很多行业也是一样),对基础知识理解的深度,在很大程度上决定了在这条路上你的上限在哪里.<br/>
</font></p>
</blockquote>

<h4 id="toc_0">背景</h4>

<p>其实很早之前我就想仔细的深入的用Swift研究一次数据结构了,但由于一直没有找到好的书籍,这个计划就被挂起了🤕.最近看喵神翻译的新书&lt;&lt;集合类型优化&gt;&gt;出版了<a href="https://objccn.io/products/optimizing-collections/preview/">传送门</a>,借此机会,正好潜心研究一下.<br/>
书中的第一节就提到了写时复制技术,这个词相信使用Swift的开发者都是既熟悉又陌生的.我也听过好多次,在Swift进阶中,我就看到过(<del>写博客的好处之一就是你想把东西讲明白要比你自己看明白深刻好几倍</del>),所以就先研究一下写时复制技术.</p>

<h4 id="toc_1">值类型和引用类型的区别,什么是值语义</h4>

<p>值类型和引用类型的区别这点顺带说一下就行,引用类型的具体表现就是我们最常用的类,通过引用计数来管理,通常我们赋值等操作,只会复制一个指针,指向它所在的内存地址,多一个引用,引用计数就+1,增加了效率,但是不安全(我在<code>Whats new in Swift4</code>这篇博客中的Encoding and decoding中有提到).值类型我们也经常用,Int类型,char,struct都是值类型,将一个值类型变量赋给另一个值类型变量时，将复制包含的值,具有新的内存地址,但这样做是代价是昂贵的(Swift做了优化,后面会解释).<br/>
那什么又是<code>值语义</code>,假设这样的场景,你有一个Class,里面所有的属性(也是引用类型的)都是私有的private,你不想让外部直接用,外部如果需要使用,可以调用暴露的get方法,你把私有属性返回给他,但其实这个时候,这个属性已经不在是私有的了,因为引用类型的特点,外部已经拿到了私有属性的指针,可以对他进行任务操作,很不安全.<br/>
<img src="media/15034498083541/15034528025928.jpg" alt="" style="width:864px;"/><br/>
图中对象b的str改变了,a中的subA对应的属性也跟着改变了.这显然不是你想要效果.需要改造一下,方法也很简单<br/>
<img src="media/15034498083541/15034533452055.jpg" alt=""/><br/>
如果是继承NSObject的类,可以直接用copy来复制.不管怎么说 效果是实现了,它是一个引用类型,但是表现的确实值类型的效果,它就具有了<code>值语义</code>.但很明显这样做的代价是昂贵的,每个get都需要重新创建一个,或复制(深copy)一个,这种消耗是我们不希望存在的.这就需要用到写实复制技术</p>

<h4 id="toc_2">什么是写时复制</h4>

<p><font color=#5F9EA0 size=3 ></p>

<blockquote>
<p>打个比方,你在公司上班,老板说每天给你80块钱,你心里算了算,说行,那一小时就是10块钱,一分钟也就是0.16666667块钱,那老板你每分钟都给我这些钱吧.老板说你小子有病吧,你想累死财务吗(这就是一个无用的消耗)?这钱又飞不了,等你要用的时候(比如你每天下班要吃饭了)我在给你不就完了么,也不耽误你呀.你一想有道理,要不然我还得每天上班带个麻袋装钱,那好吧.这样一种约定就出现了.就是有用的时候在给你,平常只是记录一下<br/>
</font><br/>
简单来说这就是写实复制技术,只有需要改变得时候,才会对变量进行复制,如果不改变,大家都公用一个内存.在 Swift 标准库中，像是 <code>Array</code>，<code>Dictionary</code> 和 <code>Set</code> 这样的集合类型是通过写时复制 (copy-on-write) 的技术实现的(摘录来自: Chris Eidhof. “Swift 进阶”) .所以我们用数组<code>Array</code>举个🌰:<br/>
<img src="media/15034498083541/15034549092312.jpg" alt=""/><br/>
可以看到,尽管数组是值类型,但是在赋值操作之后,内存还是相同的,并没有真正的进行复制.我们改变一下y,在看看:<br/>
<img src="media/15034498083541/15034552504215.jpg" alt=""/><br/>
当y发生改变的时候,y拥有了新的内存地址,它发生了赋值.这就是写时复制技术,昂贵的复制操作只会发生下变量发生改变的时候.这样做后,我们可以保证,我们的数据既是安全的也是高效的.</p>

<h4 id="toc_3">我们需要做什么</h4>

<p>当你的结构体内部都是值类型的时候,写时复制是免费的,但是大部分情况,你的结构体中有一个或多个引用类型,这个时候,写时复制需要你自己来实现了.<br/>
参考Swift进阶中,我们就用<code>NSMutableData</code>举例.<br/>
<img src="media/15034498083541/15034560622792.jpg" alt="" style="width:522px;"/><br/>
在MyData结构体中,data是私有的,我们通过dataForWriting这个计算属性来管理data,每当get操作的时候都会发生复制.并返回data.(在结构体中改变本身需要增加关键字mutating,有个这个关键字只有使用使用var声明的才可以调用).再扩展一个append方法,在调用的时候,dataForWriting会出发get方法,复制一份data,并对成员变量赋值,在对data进行更改.</p>
</blockquote>

<pre><code class="language-Swift">let theData = NSData(base64Encoded: &quot;rookieneo&quot;, options: [])!
var x = MyData(theData)
let y = x
//x.data === y.data true
x.append(x)
//x.data === y.data false
</code></pre>

<p>这样一个基本的写时复制就实现了,在赋值操作的时候,不会发生复制,但是当对变量进行更改的时候,会发生复制.但是这样做,仍然是昂贵的.因为它会在一些不需要复制的时候发生复制,比如:</p>

<pre><code class="language-Swift">let theData = NSData(base64Encoded: &quot;rookieneo&quot;, options: [])!
var x = MyData(theData)
for _ in 0..&lt;5{
    x.append(x)    
}
</code></pre>

<p>很明显,x并没有共享内存,但是复制却一直在发生.这也是我们不希望的.</p>

<h6 id="toc_4">高效方式</h6>

<p>想要不发生上文的无效复制,我们需要知道一件事,就是data属性 是不是唯一引用,在Swift中,<code>isKnownUniquelyReferenced</code>函数(是函数不是方法~)可以来检测是否是唯一引用.但是OC的类这个函数是失效的.所以我们需要对OC的类做一层封装,并对结构体加以改造.<br/>
<img src="media/15034498083541/15034575601593.jpg" alt="" style="width:615px;"/><br/>
这样改造完成后,我们发现,在get方法中,判断一下引用就可以了,只有不唯一的时候才进行复制,这样是极好的😜.只不过那个Swift的泛型封装有点丑陋,不过在swift没有完全摆脱oc的情况下,在所难免.</p>

<pre><code class="language-Swift">var  empty = MyData(NSData())
var emptyCopy = empty
for _ in 0..&lt;5{
    empty.append(theData)
}
</code></pre>

<p>现在再试一下刚才的循环,发现empty只复制了一次,也就是第一次,这样满足了我们的要求,在引用为1的时候不发生复制.到此写时复制的问题就已经解决了.不过在使用时它还有很多陷阱.</p>

<h4 id="toc_5">写时复制的陷阱</h4>

<p>让我们对比来看(伪代码).</p>

<pre><code class="language-Swift">var array = [MyData()]
array[0].append()//No copy
</code></pre>

<pre><code class="language-Swift">var dic = [&quot;rookie&quot;: MyData()]
dic[&quot;rookie&quot;]?.append()//copy
</code></pre>

<p>这看起来很奇怪,都是标准库中的类型,但是表现出来的状态是不同的,在数组下用下标取值不会有多个引用,而字典就会有,看起来数组的表现是正确的,而字典是错误的,那在字典中,我们需要怎么做,让我们来看一下书中的解释.</p>

<blockquote>
<p>如果在你将一个写时复制的结构体放到字典中，又想要避免这种复制的话，你可以将值用类封装起来，这将为值赋予引用语义。</p>

<p>当你在使用自己的结构体时，也需要将这一点牢记于心。比如，我们可以创建一个储存某个值的简单地容器类型，通过直接访问存储的属性，或者间接地使用下标，都可以访问到这个值。当我们直接访问它的时候，我们可以获取写时复制的优化，但是当我们用下标间接访问的时候，复制会发生：</p>
</blockquote>

<pre><code class="language-Swift">struct ContainerStruct&lt;A&gt; {
var storage: A
subscript(s: String) -&gt; A {
get { return storage }
set { storage = newValue }
}
}
var d = ContainerStruct(storage: COWStruct())
d.storage.change() // No copy
d[&quot;test&quot;].change() // Copy”
摘录来自: Chris Eidhof. “Swift 进阶”。 iBooks. 
</code></pre>

<p>居然还需要再用引用类型封装起来,这会让使用者疯掉的,这也是Swift未来的改进方向之一,Swift团队希望字典也表现出和Array一样的效果.之所以数组中是对的,是因为Array是通过地址器(addressors)的方式实现的下标的,地址器会直接访问内存,而不是复制.当然你也可以再自己的代码里实现地址器<a href="https://github.com/apple/swift/blob/73841a643c087e854a2f62c7e073317bd43af310/docs/proposals/Accessors.rst">-传送门-</a></p>

<h2 id="toc_6">总结</h2>

<p><font color=#5F9EA0 size=4 ></p>

<blockquote>
<p>在单向数据流方案非常流行的今天,结构体在Swift中的特性,对单项数据流有着很好的支持,包括reSwift等一些框架都已经有了一席之地,相对于双向数据流,它是安全,可控的,代码也是相对清晰的,所以写时复制的技术也就显得尤为重要,弥补了值类型性能的不足.以后在日常的开发中可以小规模的试用.😜<br/>
</font></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从切圆角引发的对iOS动画框架的探究]]></title>
    <link href="https://rookieneo.github.io/15026719129123.html"/>
    <updated>2017-08-14T08:51:52+08:00</updated>
    <id>https://rookieneo.github.io/15026719129123.html</id>
    <content type="html"><![CDATA[
<p><font color=#5F9EA0 size=4 ></p>

<blockquote>
<p>上周在开发的过程中,遇到了一个问题,就是如何只切割图片的单独一个圆角,而不是四个圆角,场景是用户在点火锅底料的时候,四宫格锅底是由四个锅拼成的,每个锅的图片都是不一样的,要拼接成一个完成的锅底,具体情况看图片,锅底的四张图片每一张都只有一个圆角.<br/>
</font></p>
</blockquote>

<p><img src="media/15026719129123/15026752741187.jpg" alt="" style="width:320px;"/></p>

<h3 id="toc_0">方案一</h3>

<p>其实这有一个非常简单的方法,就是把这四个<code>UIImageView</code>放到一个大的View中,把这个View切一个圆角,就ok了,一开始我就这这么做的,但是随后另一个问题摆在了我的面前.<br/>
<img src="media/15026719129123/15026921116631.jpg" alt="" style="width:306px;"/><br/>
就是用户在添加锅底的时候,当前为空的锅底需要显示为红色的线(像上文的图片那样),这次我再也不能投机取巧了.所以我觉得好好研究一下,第一步先从切圆角开始.</p>

<pre><code>extension UIView {
    func addRoundedCorners(withRect rect: CGRect,rectCorner: UIRectCorner,cornerRadii: CGSize){
        let maskPath = UIBezierPath(roundedRect: rect, byRoundingCorners: rectCorner, cornerRadii: cornerRadii)
        let maskLayer = CAShapeLayer()
        maskLayer.frame = rect
        maskLayer.path = maskPath.cgPath
        self.layer.mask = maskLayer
    }
}
</code></pre>

<p>非常好,调用这个方法后效果真的和第一张图一模一样,都只有一个圆角,下面开始下一步,就是在没有锅底的view中加入红线,我的想法是加上Border就可以了,so 我设置了一下border,结果是这个样子的<br/>
<img src="media/15026719129123/15026980717569.jpg" alt="" style="width:318px;"/><br/><br/>
看似挺对的,但其实是有问题的,那就是每个圆角的位置 Border都没有作用,都消失了,这是因为什么我要解释一下.<br/>
<font color=#5F9EA0 size=4 ></p>

<blockquote>
<p>首先要说一下mask这个CALayer的属性,查看API,会发现CALayer中的mask属性,也是CALayer类型的,官方的解释翻译过来意思就是layer中的可视区域,在看一下我上面的代码,创建了只有一个圆角的贝塞尔曲线,设置为layer的path,然后赋值给view的mask属性.然后在设置的是view的border,说到这,原因也就出来了,我画图解释一下.<br/>
</font></p>
</blockquote>

<p><img src="media/15026719129123/15026996232116.jpg" alt="" style="width:351px;"/><br/>
绿色部分是layer.border,而里面的圆角是mask的layer,刚才说过了,可视区域是mask里面的部分,所以圆角的那部分border看不到了.(<del>到现在我终于知道了 <code>view.layer.masksToBounds = true</code>这个属性是干嘛了</del>后来一看,好像说的不对)有同学可能会想,那把mask的border改宽不就行了吗?但经过我的测试是无效的,我认为是苹果做了特殊的设置,一个控制显示区域的layer如果还可以设置<code>borderWidth</code>和<code>borderColor</code>的话就不对了.<br/>
所以就得自己画一个layer加上去了.</p>

<pre><code>func addRoundCorneerBezierPath(rect: CGRect,roundCorneer: UIRectCorner,radii: CGSize){
        let layer = CAShapeLayer()
        layer.lineWidth = 1
        layer.strokeColor = UIColor.red.cgColor
        layer.fillColor = UIColor.clear.cgColor
        let path = UIBezierPath(roundedRect: CGRect(x: 1, y: 1, width: rect.width-2, height: rect.height-2), byRoundingCorners: roundCorneer, cornerRadii: radii)
        layer.path = path.cgPath
        self.layer.addSublayer(layer)
    }
</code></pre>

<p>CAShaperLayer是CALayer的子类.CAShapeLayer是一个图层,图层上你可以画各种东西,它的path属性就是它的路线,路线可以有很多方式来画,只不过我们选择用UIBezierPath来画而已,当然BezierPath值得研究的地方还有很多,这地就不一一细说了.CAShapeLayer也可以和CALayer一样设置frame或背景颜色,只不过一般我们用它来绘制图形.<br/>
既然已经说了这么多CA家族的东西,那就继续说一下CABasicAnimation动画和CAGradientLayer梯度图层.</p>

<h3 id="toc_1">转转转</h3>

<p><img src="media/15026719129123/haha.gif" alt="haha" style="width:150px;"/><br/>
下面做一个Demo,就是这种转转转,颜色渐变的效果.这种常见的效果在很多场景都有使用,比如蒙板,温度计,各种仪表都有使用.<br/>
首先创建一个圆环的CAShapeLayer</p>

<pre><code> let view = UIView(frame: CGRect(x: 20, y: 20, width: 200, height: 200))
        view.backgroundColor = UIColor.gray
        self.view.addSubview(view)
        let layer = CAShapeLayer()
        layer.lineWidth = 10 //线宽 
        layer.strokeStart = 0//起始点
        layer.strokeEnd = 0//结束点
        layer.strokeColor = UIColor.white.cgColor
        layer.fillColor = UIColor.clear.cgColor
        let path1 = UIBezierPath(arcCenter: CGPoint(x: 100, y: 100), radius: 45, startAngle: 1.5*CGFloat.pi, endAngle: 3.46*CGFloat.pi, clockwise: true)
        layer.path = path1.cgPath
        layer.lineCap = &quot;round&quot; //线头样式
        view.layer.addSublayer(layer)
</code></pre>

<p>然后,创建一个颜色渐变的CAGradientLayer的可视区域mask设置为上文的环形layer,因为CAShapeLayer没有能处理颜色渐变的办法,所以只能换个办法,用CAGradientLayer.CAGradientLayer的用法很简单,看到代码就会用了.它也继承自CALayer.</p>

<pre><code>let gra = CAGradientLayer()
        gra.backgroundColor = UIColor.gray.cgColor
        gra.colors = [UIColor.red.cgColor,UIColor.green.cgColor]//渐变的颜色
        gra.locations = [0.3,1]//颜色变化的百分比
        gra.frame = CGRect(x: 0, y: 0, width: 200, height: 200)
        gra.position = self.view.center
        gra.startPoint = CGPoint(x: 1, y: 0)//颜色开始的位置
        gra.endPoint = CGPoint(x: 1, y: 1)//颜色结束的位置
        gra.mask = layer//  通过mask属性来截取渐变层
        self.view.layer.addSublayer(gra)
</code></pre>

<p><img src="media/15026719129123/15028679902914.jpg" alt="" style="width:317px;"/></p>

<p>效果是这样的,当你把gra.mask设置为上文的环形layer的时候.<br/>
<img src="media/15026719129123/15028680909612.jpg" alt="" style="width:181px;"/></p>

<p>OK了,最后就是让它动起来了.想要动起来需要用到CABasicAnimation这个类,来控制<code>layer.strokeStart = 0//起始点 layer.strokeEnd = 0//结束点</code>,简单来说这个动画可以分为两部分,第一分部,layer.strokeEnd的值从零到1,第二部分,layer.strokeStart的值从0到1.然后循环代用就👌了</p>

<pre><code>var an : CABasicAnimation!
an = CABasicAnimation(keyPath: &quot;strokeEnd&quot;)
        an.duration = 1
        an.fromValue = 0
        an.toValue = 1
        an.delegate = self//设置代理在第一部分的动画结束的时候,开始第二部分的动画.
        an.isRemovedOnCompletion = false
        an.fillMode = kCAFillModeForwards
//        an.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn)
        an.timingFunction = CAMediaTimingFunction(controlPoints: 0.17, 0.76, 0.71, 0.15)
        self.layer.add(an, forKey: &quot;com.CABasicAnimation1&quot;)
</code></pre>

<blockquote>
<p>在CABasicAnimation中有三个属性,需要说明一下,第一个就是an.isRemovedOnCompletion = false,这属性的意思是在动画结束后是回到动画之前的layer还是保持动画之后的layer,第二个是an.fillMode = kCAFillModeForwards,这个属性只有在上一个属性是false的时候才会有效果.<a href="http://www.jianshu.com/p/91fccd32f6fb">这些属性有什么不同,这边博客有详细的说明</a>,以下说明是复制他文章中提到的.<br/>
fillMode：决定当前对象在非active时间段的行为.比如动画开始之前,动画结束之后<br/>
kCAFillModeRemoved 这个是默认值,也就是说当动画开始前和动画结束后,动画对layer都没有影响,动画结束后,layer会恢复到之前的状态（可以理解为动画执行完成后移除）</p>

<p>kCAFillModeForwards 当动画结束后,layer会一直保持着动画最后的状态</p>

<p>kCAFillModeBackwards 当在动画开始前,你只要把layer加入到一个动画中,layer便立即进入动画的初始状态并等待动画开始.你可以这样设定测试代码,延迟3秒让动画开始,只要动画被加入了layer,layer便处于动画初始状态<br/>
第三个属性 an.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn),是动画持续这段时间的状态,苹果提供了几个简单的,先快后慢等,如果觉得不满意,可以自己写一个贝塞尔曲线去,类似于这种<code>an.timingFunction = CAMediaTimingFunction(controlPoints: 0.17, 0.76, 0.71, 0.15)</code>当然至于为什么贝塞尔曲线可以干这么多事,你可以去复习一下高中数学,顺便把导数,极限,微积分什么的都看看,充分体现了为什么数学学的好的人,代码写的好了.</p>
</blockquote>

<pre><code>extension ViewController : CAAnimationDelegate{
    public func animationDidStop(_ anim: CAAnimation, finished flag: Bool){
        if let aa = self.layer.animation(forKey: &quot;asd&quot;),anim == aa{
            self.addFill12()//第二部分动画
        }else{
            layer.removeAllAnimations()//注意在下一次动画开始的时候要移除之前的动画
            self.btnClick(1)//第一部分动画
        }
    }
}
var an1 : CABasicAnimation!
    func addFill12() {
        an1 = CABasicAnimation(keyPath: &quot;strokeStart&quot;)
        an1.duration = 1
        an1.fromValue = 0
        an1.toValue = 1
        an1.delegate = self
        an1.isRemovedOnCompletion = false
        an1.fillMode = kCAFillModeForwards
        an1.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn)
        self.layer.add(an1, forKey: &quot;com.CABasicAnimation2&quot;)
    }
</code></pre>

<h4 id="toc_2">总结</h4>

<blockquote>
<p>这篇博客只是说了一些简单的动画是如何实现的,如果从实现的角度来讲,我觉得没有什么难度,个人感觉真正难的地方在于复杂动画时,对于各种动画路线,函数,效果的计算,对于我这种高中数学忘的差不多的人来说,确实是个挑战.如果有机会,下一篇微博我会亲自试一试复杂动画的实现,看一看自己的数学功底.<br/>
<a href="https://github.com/RookieNeo/CALayer">Demo</a></p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于Alamofire网络库的二次封装]]></title>
    <link href="https://rookieneo.github.io/15017218903153.html"/>
    <updated>2017-08-03T08:58:10+08:00</updated>
    <id>https://rookieneo.github.io/15017218903153.html</id>
    <content type="html"><![CDATA[
<p>Alamofire作为一个Swift的网络框架被开发者们大量使用在自己的项目中,但处于公司的业务,统一处理,后期换库  <del>但实际可能永远不会</del> 等多方面的考虑,一般都会对其进行二次封装.由于公司项目的网络框架是我写的,并进过了多次重构,优化,我觉得可以满足大部分的日常需要,所以我准备拿出来和大家讨论一下.</p>

<h4 id="toc_0">1</h4>

<p>首先我准备把框架分为业务层,数据层(整合数据,加密,统一处理的位置)和最后的网络层.其实之前也有想直接分两层,但是为了换库的时候没有痛感,最后还是考虑分为三层了,将网络层由中间层调用,所以换库之后,业务层不会有改动,而且数据整合解析层 也不会有改动.而且还有一点考虑,之后我会提到.<br/>
<img src="media/15017218903153/15018086716115.jpg" alt="" style="width:234px;"/><br/>
下面我就说一下我设计时候的思路.</p>

<h4 id="toc_1">2定义接口</h4>

<p>也就是业务层需要发起网络请求时候的接口.我定义的接口是这样的<br/>
<img src="media/15017218903153/15018095032823.jpg" alt="" style="width:2800px;"/></p>

<pre><code>@discardableResult class func request(withInterface interface: URLConfig,requestData: [String:Any]?,method : NetHTTPMethod = .Post,serverType : RequestType = RequestType.hhtServer,completed: @escaping(_ dataResult : DataResult&lt;Dictionary&lt;String, Any&gt;&gt;) -&gt; Void) -&gt; URLSessionTask?
</code></pre>

<p>至于为什么定义成这样子,我一个参数一个参数的解释,其实解释完了,这篇博客也就差不多了.</p>

<h6 id="toc_2">首先第一个参数interface: URLConfig</h6>

<p>URLConfig是一个协议.内容很简单</p>

<pre><code>protocol URLConfig{
    func getPath() -&gt; String
}
</code></pre>

<p>就只有一个<code>getPath</code>的方法,目的是获取接口的url路径,有人会说,那为什么要定义一个协议呢?直接一个<code>String</code>类型不就可以了吗?这样做有一个好处,大家有没有发现,让你直接调用Alamofire的时候,可以传String,也可以传URL,都可以,因为它的类型也是一个协议呀,String和URL都实现了这个协议就ok拉,所以我也是这样做的.其实就是面向对象中的多态.</p>

<h6 id="toc_3">接口的管理</h6>

<p>在项目中我是用枚举关联String管理接口的,这样的好处是接口统一在一个位置,清晰,易扩展,好维护.<br/>
<img src="media/15017218903153/15018108531635.jpg" alt=""/><br/>
枚举同样也实现了URLConfig协议,在调用网络接口的时候,第一个参数只需要填入<code>InterfaceEnum.devAuth</code>就可以了,可能有朋友会有疑问,基本每个公司开发接口,测试接口,正式接口,有的时候你们公司对接别的服务器,还有有不同的协议,比如你们用https他们用http的情况,切换环境,我用一个全局变量就ok了,就是NetConfig.curServerIP,只要把curServerIP换了,环境也就切换了,但是一部分用http,另一部分用https,或有的时候你和同事联调,100个接口有10个跑他的ip,90个跑服务器的,怎么办呢?其实很简单,这就体现了协议的好处,你在建一个<code>InterfaceXXXXEnum</code>,再实现一个getPath协议,这次你可以拼接成https://  也可以拼接成ftp的都可以了,这样做之后,你会发现,你的接口管理的很清晰,那个接口是http的  哪个是https的,哪个是XXX的,一看就知道了,统一了管理.</p>

<h6 id="toc_4">第二个参数是接口中需要的参数,这个没啥好说的</h6>

<h6 id="toc_5">第三个是请求的方式</h6>

<p>是GET还是POST,按理说这个也没啥好说的,但是有一点我希望在这里说明,也就是我上文我说的之后我会说的,由于我们用的是AlamoFire,他有自己的请求类型枚举<br/>
<img src="media/15017218903153/15018121396577.jpg" alt=""/><br/>
但是我不想用它,因为我们进行二次封装的目的是什么,是隔离,不想让他对项目有太多的入侵,所以这也是我建这个中间层的第二个目的,在中间层,把所有数据转换成Foundation框架的基本类型,传递给Alamofire,这样,后期无论怎么换,只要有Foundation在,我的框架就不由会大问题.所以我自己也建了一个枚举跟上面的枚举差不多,只不过区别是他是他的,我是我的~~.<br/>
<img src="media/15017218903153/15018126056939.jpg" alt=""/></p>

<h6 id="toc_6">第四个参数,serverType</h6>

<p>在实际开发中,有很多时候你对接的不是一个服务器,比如美团,微信,阿里他的项目中嵌入了好多别人的项目,虽然这些项目的网络请求会在自己的sdk中解决,但是难免会出现一个项目跑两个服务器的情况,就像我们公司海底捞重构的项目,前端和后端一起重构,但是前端之前有过UI重构的经验了,所以写起来要比后端快的多,所以我们在重构的时候大部分还是用的老接口,这时候,有个后端的大哥说,那个我这几个接口做好了,你试试吧,但是他的这几个接口是有前置条件了,但这些前置条件在新的服务器中还没有实现,这时候你就需要前置接口调用老服务器,新接口调用新服务器,不同的服务器,加密解密方式,数据的拼接要求肯定是不同的,所以我就又造了一个枚举,<code>ServerType</code><br/>
<img src="media/15017218903153/15018134572100.jpg" alt=""/><br/>
有个这个枚举之后,就可以根据不用的服务器,做不同的加密,数据返回后做不同的解析了.</p>

<h6 id="toc_7">然后就是最后一个参数了,回调函数.</h6>

<p>这个回调函数其实也没什么说的,但是我对数据做了一层封装,就是DataResult的数据类型,至于为什么,我的Swift的一种常用类型那篇博文里有说明,大家可以去看看.</p>

<h6 id="toc_8">最后作为一个网络请求,你的返回值是什么</h6>

<p>它是什么,取决你要拿它干嘛用,很多时候,在轮询的场景下,一个请求没完成,不能发起下一个请求,或是把上一个请求取消,所以我就把<code>URLSessionTask</code>返回了,其实Alamofire也有自己的Task,但是我还是坚持返回了<code>Foundation</code>框架里的类型,至于为啥就不多说了.</p>

<h4 id="toc_9">3核心的实现</h4>

<p>网络核心层当然后调用Alamofire了,这部分就比较简单了.在这之前,先看下上面讲的接口的实现.<br/>
<img src="media/15017218903153/15018136557339.jpg" alt=""/><br/>
default就是核心层的单例</p>

<pre><code>private static let `default` : RequestManagerProtocol = RequestManager()
</code></pre>

<p><img src="media/15017218903153/15018138410087.jpg" alt=""/><br/>
这一层中,还是一个协议,保证了接口的统一,如果有换库等行为,只要实现了这个协议,就可以保证对外暴露的接口不变.        </p>

<h4 id="toc_10">业务层的调用</h4>

<p>尽管我们接口中有很多参数,但是大部分都有默认参数,所以大部分情况下,业务端是不需要知道全部参数的,他只需要知道两个参数,一个是接口地址,一个是要传的参数</p>

<pre><code>NetRequest.request(withInterface: InterfaceEnum.cashNeedMoney, requestData: params) { (data) in
            switch data {
            case .failure(let error):
                complete(DataResult.failure(error))
            case .success(let value):
                let money = (value[&quot;DATA&quot;] as? NSNumber) ?? 0
                complete(DataResult.success(money))
            }
        }
</code></pre>

<p>仅此而已,这就够了.</p>

<h4 id="toc_11">思考</h4>

<p>到目前为止,我的这个封装完全满足了项目的需求,但是也有在考虑要不要增加返回数据的类型,现在我只支持返回字典,但是这样做我也是有自己的想法的,因为一个项目业务端的解析方式大都很固定,我给他们暴露了太多的接口,反而会导致业务端调用的混乱,毕竟我是二次封装,如果写的太多了,就不是二次封装了.下一篇博客,我会分析Alamofire的源码,并提出我的疑惑,欢迎来撕~</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中对于有先后顺序的网络请求的优化]]></title>
    <link href="https://rookieneo.github.io/15008764200399.html"/>
    <updated>2017-07-24T14:07:00+08:00</updated>
    <id>https://rookieneo.github.io/15008764200399.html</id>
    <content type="html"><![CDATA[
<p>在实际开发中会有很多场景是需要发送多个网络请求的,并且它们之间有逻辑关系,比如餐厅APP中,用户需要先确认账单才能打印账单,并且是确认账单成功了才能打印账单,对于这种问题有几种解决方法:</p>

<h4 id="toc_0">1让后端的大哥改下</h4>

<p>也就是说你可以找你的后端让他帮你在确认账单接口调用的时候调用下打印账单的方法,说实话以前我真的喜欢这么干,但是后来我发现我错了,因为这样做两个业务就耦合在一起了,如果以后还有人要调用这个接口,他绝对想不到这个接口还会触发打印.所以这不是一个好办法.</p>

<h4 id="toc_1">2嵌套调用</h4>

<p><img src="media/15008764200399/15008775374587.jpg" alt=""/></p>

<p>这是我最开始写的代码,我在调用确认账单,并且返回成功了之后,又调用了打印账单.这样做看似是可以了,但是不够好,因为这才两个请求,如果有四五请求有这种业务上的需求,嵌套在一起就回显得很乱,比如:<br/>
<img src="media/15008764200399/15008777031048.jpg" alt=""/></p>

<p>相信在你看到这种网络请求的时候各种各样的回调的时候,你是绝望的.它很不清晰,把闭包的缺点表现的淋漓尽致.所以这个方法也不好,但它是可用的.</p>

<h4 id="toc_2">3依赖队列</h4>

<p><img src="media/15008764200399/15008778898419.jpg" alt=""/></p>

<p>这是我使用队列最初的想法,首先这两个网络请求是串行的,我的想法是用依赖,printOp依赖于makeSureOp,也就是说只有当确认账单的请求执行完了之后,才会调用打印的接口.事物总是看似美好,其实并没有这么简单.这中队列是不行的,原因有两点,第一点,第一个任务无论最后是成功还是失败,都会调用打印任务,这样是不符合业务.第二点因为网络请求是异步的,所以这个依赖的添加是无效的,第一个任务的网络请求还没有返回,第二个就已经开始了,这个位置我也不是特别理解,为什么依赖是能在同一线程中起作用.</p>

<h4 id="toc_3">优化队列</h4>

<p><img src="media/15008764200399/15008784802926.jpg" alt=""/></p>

<p>这是我优化之后的方法.首先向队列中添加一个确认账单的任务,在成功之后再向队列中添加打印任务.这样做之后,业务实现了,代码也清晰了,就有4 5个有顺序的请求,也很清晰,只需要在成功的地方向队列中添加任务就可以了.<br/>
总结:<br/>
    在实际开发中,这种需求有别于批量下载图片的需求,因为批量下载图片任务之间并没有业务关系,你完全可以建一个GCD的组,每一次下载图片的时候都向组里添加任务,当组中的任务都完成的之后,就是所有图片都下载完了,就算下载不成功,对后续的任务也不会有影响.但是它解决不了接口和接口直接有业务关系的问题,因为下载图片,每个任务都是独立的,异步的,但是这个问题,所有的请求其实是串行的,同步的,有关系的.所以我采用的这种方法来实现,具体怎么样,还需要实践.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Whats-new-in-swift-4 (下)]]></title>
    <link href="https://rookieneo.github.io/14970555001135.html"/>
    <updated>2017-06-10T08:45:00+08:00</updated>
    <id>https://rookieneo.github.io/14970555001135.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">Dictionary and Set enhancements</h4>

<p>关于字典的改进都是很直观的.</p>

<pre><code>let names = [&quot;Cagney&quot;, &quot;Lacey&quot;, &quot;Bensen&quot;]
let dict = Dictionary(uniqueKeysWithValues: zip(1..., names))
//print [2: &quot;Lacey&quot;, 3: &quot;Bensen&quot;, 1: &quot;Cagney&quot;]
dict[2]
print Lacey
//
</code></pre>

<pre><code>let contacts = [&quot;Julia&quot;, &quot;Susan&quot;, &quot;John&quot;, &quot;Alice&quot;, &quot;Alex&quot;]
let grouped = Dictionary(grouping: contacts, by: { $0.first! })
grouped
//print [&quot;J&quot;: [&quot;Julia&quot;, &quot;John&quot;], &quot;S&quot;: [&quot;Susan&quot;], &quot;A&quot;: [&quot;Alice&quot;, &quot;Alex&quot;]]
</code></pre>

<p>很多时候服务器返回的JSON并不会给你分组,但是很有需求是需要在list中分组的,这个方法是很好的.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Whats-new-in-swift-4 (上)]]></title>
    <link href="https://rookieneo.github.io/14969065461458.html"/>
    <updated>2017-06-08T15:22:26+08:00</updated>
    <id>https://rookieneo.github.io/14969065461458.html</id>
    <content type="html"><![CDATA[
<p>Swift4终于到4了,这次升级对之前的版本有很好的兼容,而且也有一些很不错的API<br/>
于是我是看了 Ole Begemann这位外国友人的github的Swift4的playground<a href="https://github.com/ole/whats-new-in-swift-4">传送门</a>总结了一下,这种东西,还是老外搞得好,国内真的不行...</p>

<h4 id="toc_0">Strings</h4>

<ol>
<li>第一个就是String,增加了<code>&quot;&quot;&quot;</code>这个功能
栗子:</li>
</ol>

<pre><code class="language-swift">let multilineString = &quot;&quot;&quot;
        This is a multi-line string.
    You don&#39;t have to escape &quot;quotes&quot; in here.
    The position of the closing delimiter
      controls whitespace stripping
    &quot;&quot;&quot;
print(multilineString)
</code></pre>

<p>打印出来的效果是这个样子的<br/>
<img src="media/14969065461458/14969075270793.jpg" alt=""/><br/>
没错,就是和你在代码里写的空行一模一样,不需要打换行符和空格了,不知道大家觉得如何,我是觉得非常好,因为...<br/>
<img src="media/14969065461458/14969077073633.jpg" alt=""/><br/>
我只是为了让网络请求的打印的日志好看一点,把代码写成这样也是很蓝瘦的,不过现在有&quot;&quot;&quot;就好了<br/>
2. String终于有.count了 不容易,而且取subString什么的更容易了,我自己项目里的String的extension终于可以去掉了,人家写的确实比我好,嘿嘿</p>

<pre><code class="language-swift">let greeting = &quot;Hello, 😜!&quot;
let comma = greeting.index(of: &quot;,&quot;)!
let substring = greeting[..&lt;comma]
//print Hello
</code></pre>

<h4 id="toc_1">SubScripts</h4>

<p>1.<br/>
这个不用说,秒懂,感觉还好,以前用着也不费劲</p>

<pre><code class="language-swift">let numbers = [1,2,3,4,5,6,7,8,9,10]
numbers[5...] // instead of numbers[5..&lt;numbers.endIndex]
//print Hello
</code></pre>

<h4 id="toc_2">Private declarations visible in same-file extensions</h4>

<p>同一个文件下的Extensions中用到的Private属性可以不用改为filePrivate了,这个改动很好,因为同一个文件下的类的扩展,本身就同一个类,为什么我在类的方法中调用自己的属性,还需要用fileprivate,就很奇怪,当初我用的时候就感觉很难受,一使用extension就需要改权限...<br/>
<img src="media/14969065461458/14969090403987.jpg" alt=""/><br/>
如果在swift3中,stroage这个属性是要改成fileprivate的.</p>

<h4 id="toc_3">Key Paths</h4>

<p><img src="media/14969065461458/14969097853215.jpg" alt="" style="width:1860px;"/></p>

<pre><code class="language-swift">sicp[keyPath: \Book.title]
sicp.title
//print same Structure and Interpretation of Computer Programs
sicp[keyPath: \Book.title]
sicp[keyPath: \Book.primaryAuthor.name]
//print Harold Abelson
</code></pre>

<p>结构体中的属性可以像路径一样被取出<br/>
当然也可以拼接路径 就像这样</p>

<pre><code class="language-Swfit">let authorKeyPath = \Book.primaryAuthor
type(of: authorKeyPath)
let nameKeyPath = authorKeyPath.appending(path: \.name) // you can omit the type name if the compiler can infer it
sicp[keyPath: nameKeyPath]
//print  Harold Abelson
</code></pre>

<p>虽然我现在也不是太理解这样好处,但是能感觉出来这个一个很重大的改进,很多大神都可能会在这做文章,期待.</p>

<h4 id="toc_4">Encoding and decoding 重头戏</h4>

<p>这个是已经被公认的一个重大的提升,先举栗子</p>

<p><img src="media/14969065461458/14969104547178.jpg" alt=""/><br/>
这是一个结构体,有一点特殊,它遵循了Codable协议,hand数组中初始化了两个Card.<br/>
然后~<br/>
Encoding</p>

<pre><code class="language-Swfit">var encoder = JSONEncoder()

// Properties offered by JSONEncoder to customize output
encoder.dataEncodingStrategy
encoder.dateEncodingStrategy
encoder.nonConformingFloatEncodingStrategy
encoder.outputFormatting
encoder.userInfo

let jsonData = try encoder.encode(hand)
String(data: jsonData, encoding: .utf8)
//print &quot;[{\&quot;rank\&quot;:1,\&quot;suit\&quot;:\&quot;clubs\&quot;},{\&quot;rank\&quot;:12,\&quot;suit\&quot;:\&quot;hearts\&quot;}]&quot;
//你没有看错  它是JSON了
</code></pre>

<p>Decoding</p>

<pre><code class="language-Swift">let decoder = JSONDecoder()
let decoded = try decoder.decode([Card].self, from: jsonData)
// decoder 现在和截图中hand是一模一样的了666
</code></pre>

<p>系统的API帮我们做了json解析,这是非常好的.<br/>
结构体是值类型,适用于单向数据流的数据传输方式,不过移动端的数据流一般都是双向的,意思就是你引用了别人的model,你把model中的数据给改了,那别人的model对应的数据也改了,因为大家的model用的都是类,而不是结构体,是引用类型,这样做在移动端是很方便的,但是也有很多弊端,比如你改了别人的数据,但是那哥们却不知道,这是很危险的,如果项目比较大,这老哥就为了知道是谁改了他数据就能找半天,但是结构体是值类型,就不会有这个问题,因为每次赋值,都是一个新的,这样就很安全,但是你每次改数据都需要调用别人的接口,这样就会很繁琐,而且数据的一致性和保持不了,在web前端有流行的框架中,react,vue(排名不分先后)都是单向数据,但是他们也有双向绑定的机制,也有很好的框架保证数据的准确.移动端这样的框架也有,只不过没有流行起来<br/>
所以我就测试了一下类是不是也可以这样搞,结果是可以,皆大欢喜,引用类型也可以遵循Codable协议,来实现和JSON数据的互转.</p>

<h4 id="toc_5">Generic subscripts 角标方法中可以使用泛型了</h4>

<p>这是一个很好的消息,这会使得subscripts的使用变得更广泛,更已用,我在之前封装的UserDefaults方法中就因为角标方法中不能使用泛型限制了我的思路,现在终于可以实现了. </p>

<pre><code class="language-Swift">subscript&lt;T&gt;(key: String) -&gt; T? {
        return storage[key] as? T
    }
</code></pre>

<p>相信用过subscipt方法的看到这个栗子会很激动,没用过的,也感受不到Swift3中不能使用泛型的困扰了</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中对UserDefaults的封装]]></title>
    <link href="https://rookieneo.github.io/14956811508929.html"/>
    <updated>2017-05-25T10:59:10+08:00</updated>
    <id>https://rookieneo.github.io/14956811508929.html</id>
    <content type="html"><![CDATA[
<p>Founddation中UserDefaults是一种很轻量化的本地化工具,实际开发中经常会使用,由于苹果中很多类库还没有用Swift重写,所以在Swift中用UserDefaults就显示不是很Swift,还是OC的感觉,所以我就想对UserDefaults进行一次封装,让它更Swift,用起来更方便.我最早由这种想法实在Swift2的时候,那时候就感觉用起来不是很方便了,但是没有多想,之后又看到了一篇文章<a href="http://radex.io/swift/nsuserdefaults/">传送门</a>,它是用Swift中subscript的方法对NSUserDefaults进行了封装,Swift中,Dic[key],Array[index],都是使用了subscript方法.我就是参照这位外国友人的思路进行了封装.</p>

<h2 id="toc_0">[subscript] + 泛型 的方式</h2>

<p>这是我最开始的设计思路,先看代码</p>

<pre><code class="language-Swift">protocol UserDefaultProtocol {
    func getKey() -&gt; String
}
enum DefaultsKey: String,UserDefaultProtocol {
    case token
    case name
    case mobile
    func getKey() -&gt; String {
        return self.rawValue
    }
}
public let Defaults = UserDefaults.standard
extension UserDefaults {
    
    subscript(key: UserDefaultProtocol) -&gt; Fakegenericity {
        return Fakegenericity(self, key.getKey())
    }
    subscript(key: UserDefaultProtocol) -&gt; Any?{
        get{
            let genericity : Fakegenericity = self[key]
            return genericity
        }
        set{
            guard let newValue = newValue else {
                removeObject(forKey: key.getKey())
                return
            }
            switch newValue {
            case let v as Double:
                self.set(v, forKey: key.getKey())
            case let v as Int:
                self.set(v, forKey: key.getKey())
            case let v as Bool:
                self.set(v, forKey: key.getKey())
            case let v as URL:
                self.set(v, forKey: key.getKey())
            default:
                self.set(newValue, forKey: key.getKey())
            }
        }
    }
    ///直接根据key取int  double等  就算取不到  也会返回 0  当有要存储0的需求时候  会有问题  所以 用过根据 object 去数据转 nsnumer  判断number?  使取 bool int等类型时  没有值会返回nil
    func numberForKey(_ key: String) -&gt; NSNumber? {
        return object(forKey: key) as? NSNumber
    }
    
    /// Returns `true` if `key` exists
    func hasKey(key: UserDefaultProtocol) -&gt; Bool {
        return object(forKey: key.getKey()) != nil
    }
    
    func removeAll(){
        for(key,_) in dictionaryRepresentation() {
            removeObject(forKey: key)
        }
    }
    func remove(key: UserDefaultProtocol){
        removeObject(forKey: key.getKey())
    }
    class Fakegenericity {
        fileprivate let defaults: UserDefaults
        fileprivate let key: String
        
        fileprivate init(_ defaults: UserDefaults, _ key: String) {
            self.defaults = defaults
            self.key = key
        }
        
        // MARK: only - get
        public var object: Any? {
            return defaults.object(forKey: key)
        }
        
        public var string: String? {
            return defaults.string(forKey: key)
        }
        
        public var array: [Any]? {
            return defaults.array(forKey: key)
        }
        
        public var dictionary: [String: Any]? {
            return defaults.dictionary(forKey: key)
        }
        
        public var data: Data? {
            return defaults.data(forKey: key)
        }
        
        //        public var date: Date? {
        //            return object as? Date
        //        }
        
        public var number: NSNumber? {
            return defaults.numberForKey(key)
        }
        
        public var int: Int? {
            return number?.intValue
        }
        
        public var double: Double? {
            return number?.doubleValue
        }
        
        public var bool: Bool? {
            return number?.boolValue
        }
        
        
        public var stringValue: String {
            return string ?? &quot;&quot;
        }
        
        public var arrayValue: [Any] {
            return array ?? []
        }
        
        public var dictionaryValue: [String: Any] {
            return dictionary ?? [:]
        }
        
        public var dataValue: Data {
            return data ?? Data()
        }
        
        public var intValue: Int {
            return int ?? 0
        }
        
        public var doubleValue: Double {
            return double ?? 0
        }
        
        public var boolValue: Bool {
            return bool ?? false
        }
    }
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift的一种常用类型]]></title>
    <link href="https://rookieneo.github.io/14936932217611.html"/>
    <updated>2017-05-02T10:47:01+08:00</updated>
    <id>https://rookieneo.github.io/14936932217611.html</id>
    <content type="html"><![CDATA[
<p><img src="media/14936911497977/14936911882116.jpg" alt=""/></p>

<h6 id="toc_0">这是我在公司项目用到的一种用于网络请求返回数据的类型,我第一次见到它是Alamofire的源码中,他对网络请求的数据就进行了一种这样的封装,当时就觉得不错,不过并没有在意,后来又在喵神翻译的swift进阶中又看了,于是就抱着试一试的态度用一下,果然效果还是不错的.</h6>

<h5 id="toc_1">我个人认为这是一个加强版的可选类型,其实可选类型就是一个枚举值,有value和nil两个枚举值,这个DataResult也是一个枚举值,有error和value两种枚举值,区别是可选类型对返回时nil的情况并不在意,更在意的是结果,只要告诉我有或者没有就可以了,而DataResult类型比可选类型更重视返回错误时的情况,所以我觉得这很适合用在网络请求的返回值中,有数据的时候就是成功,没有数据的时候就是失败,失败的时候返回error类型给业务层做相应的处理.</h5>

<p><img src="media/14936911497977/14936925384241.jpg" alt=""/><br/>
这是业务层的使用情况,data就是DataResult类型,也可以使用if else 还做处理,这就是extension中isSuccess和isFailure的作用.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[按钮加下拉弹框控件的封装]]></title>
    <link href="https://rookieneo.github.io/14924176125873.html"/>
    <updated>2017-04-17T16:26:52+08:00</updated>
    <id>https://rookieneo.github.io/14924176125873.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">直接上图</h4>

<p><img src="media/14924176125873/1F2A7756-BAA8-4521-8122-3C2F3C180AD5.png" alt="1F2A7756-BAA8-4521-8122-3C2F3C180AD5"/><br/>
由于项目里用到好多这种点击上面的按钮,下拉出一个tableView弹框的需求,所以我决定单独封装一个.</p>

<h4 id="toc_1">需求和思路</h4>

<ol>
<li>需求:点击上面的按钮,弹出一个下拉框,点击下拉框中的cell,tableView消失,按钮刷新为选中的cell.</li>
<li>思路:因为有些地方用上面的按钮控件,有些地方只用下面的控件,有些地方又两个要在一起用,所以我决定封装两个简单的View控件,在单独封装一个View,将两个控件做到一起.</li>
</ol>

<h4 id="toc_2">Go!</h4>

<ol>
<li>封装按钮控件</li>
</ol>

<p><img src="media/14924176125873/WechatIMG243.jpeg" alt="WechatIMG243"/></p>

<p>既然是封装,那么这个按钮的宽度就一定不能是死的,所以我决定只设置红色位置的layout,整体控件的宽度由&quot;班次&quot;&quot;全部&quot;两个Label和图片撑开,传入的String多宽控件就多宽.<br/>
   UI的问题解决了,剩下的就是如何初始化和配置还有时间传递的问题了,首先要使用这个控件就必须有两个参数,就是两个String,所以我在初始化方法中添加两个参数,而例如两个Label的颜色这种数据作为public属性,可配置.当然还需要两个get set方法的属性,用于初始化控件后,改变控件上的文字,so,控件的初始化方法和暴露的属性是这个样子的:<br/>
   <img src="media/14924176125873/WechatIMG247.jpeg" alt="WechatIMG247" style="width:572px;"/><br/>
图中代码上面的初始化的方法和属性,两个Public属性的get和set方法是用于读和设置label的,之所以这么做是因为我觉得分装的控件不应该暴露出UIlabel这种东西(个人想法)所以我用了这种方法对label做了一层处理而真正的label是private的.还有一点要说的是第二个框的代码,我构建UI的位置是在viewdidMovetoSuperView中的时候,是因为放在初始化中会导致设置的字体颜色无效,因为给label设置颜色的位置在configUI方法中.在初始化中调用会导致先调用了configUI,然后才给left or right Color 赋值.点击的事件我选择用代理方法,参数是btn选中的状态ture or false.<br/>
2. 封装下拉控件<br/>
<img src="media/14924176125873/14924213229065.jpg" alt=""/><br/>
下拉控件中,我是暴露了一个属性,就是tableView每一个行的高度,初始化中,必须传入tableView的数据.并设置了tableView的阴影,因为项目里的这个控件都需要有阴影,如果其他项目不需要其实可以暴露一个bool属性,控制一下阴影效果.<br/>
<img src="media/14924176125873/14924214894815.jpg" alt=""/></p>

<ol>
<li>将两个控件封装成一个控件
<img src="media/14924176125873/14924215554777.jpg" alt=""/></li>
</ol>

<p>这是我封装的新控件的所有暴露的方法,我会一个个的解释这个写的目的,首先第一个属性,isAppeared属性,在每次set之后都会判断它的值,如果是true就创建下拉tableView的控件,如果是false就删除.现在didset中的目的就是配合第一个按钮的控件<br/>
<img src="media/14924176125873/14924217419848.jpg" alt=""/><br/>
这是按钮控件的代理方法的实现,在这个代理方法中,我只需要改变一下isAppear的值就可以控制显示隐藏,而isAppear的值就是按钮控件通过代理方法传给我的值,可能有朋友会觉得那把isAppeard里的代码放到按钮控件的代理方法不也一样么,这个地方我的想法是下拉控件的显示和隐藏不应该是有控件的内部可以控制,如果我点出了拉下控件,用户点击别的位置,按照用户习惯,这个弹框应该收起,所以我才写了isAppeared这个属性,这样以来,外部和内部都可以控制下拉控件的显示和隐藏.<br/>
剩下的pullDownHeight和listViewHeight属性是用来控制整个控件的高度和下拉控件的高度的,至于为什么没有暴露出设置宽度的属性,是因为我觉觉得这个控件既然是两个控件的融合,那么下拉框的宽度因为和按钮控件保持一致,而按钮控件的宽度又是由里面的title决定的,所以我没有暴露出宽度的属性.<br/>
<img src="media/14924176125873/14924223637448.jpg" alt=""/><br/>
最后实现拉下控件的代理方法,根据用户点击的cell改变按钮控件的rightLabel的text,当然也是通过修改按钮控件暴露的rightText属性的set方法,而不是直接修改Label的方式.个人认为比较优雅一下,直接改label感觉很暴力.最后在将点击的时间传在control层,分别将点击的index和title传出,方便使用者根据用户的点击做出响应.</p>

<h4 id="toc_3">总结</h4>

<p>其实这个控件的分装没有太大的难度,我自己觉得通过这次封装,一是将两个控件封装到一起,并且其中任何一个控件又都可以单独拿出来用的这种封装方式有了一定的认识,二是如何封装出优雅的可用的控件,不该暴露的属性就不要多暴露,让使用者一目了然,初始化的方法参数能少则少,参数越多,使用难度越大,一起不必要的参数都设置为有默认值可配置的形式.<br/>
代码我会在稍后传到我的github上<br/>
<a href="https://github.com/RookieNeo">传送门</a></p>

]]></content>
  </entry>
  
</feed>
