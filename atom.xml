<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[RookieNeo]]></title>
  <link href="https://rookieneo.github.io/atom.xml" rel="self"/>
  <link href="https://rookieneo.github.io/"/>
  <updated>2017-08-04T13:40:26+08:00</updated>
  <id>https://rookieneo.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[基于Alamofire网络库的二次封装]]></title>
    <link href="https://rookieneo.github.io/15017218903153.html"/>
    <updated>2017-08-03T08:58:10+08:00</updated>
    <id>https://rookieneo.github.io/15017218903153.html</id>
    <content type="html"><![CDATA[
<p>Alamofire作为一个Swift的网络框架被开发者们大量使用在自己的项目中,但处于公司的业务,统一处理,后期换库  <del>但实际可能永远不会</del> 等多方面的考虑,一般都会对其进行二次封装.由于公司项目的网络框架是我写的,并进过了多次重构,优化,我觉得可以满足大部分的日常需要,所以我准备拿出来和大家讨论一下.</p>

<h4 id="toc_0">1</h4>

<p>首先我准备把框架分为业务层,数据层(整合数据,加密,统一处理的位置)和最后的网络层.其实之前也有想直接分两层,但是为了换库的时候没有痛感,最后还是考虑分为三层了,将网络层由中间层调用,所以换库之后,业务层不会有改动,而且数据整合解析层 也不会有改动.而且还有一点考虑,之后我会提到.<br/>
<img src="media/15017218903153/15018086716115.jpg" alt="" style="width:234px;"/><br/>
下面我就说一下我设计时候的思路.</p>

<h4 id="toc_1">2定义接口</h4>

<p>也就是业务层需要发起网络请求时候的接口.我定义的接口是这样的<br/>
<img src="media/15017218903153/15018095032823.jpg" alt="" style="width:2800px;"/></p>

<pre><code>@discardableResult class func request(withInterface interface: URLConfig,requestData: [String:Any]?,method : NetHTTPMethod = .Post,serverType : RequestType = RequestType.hhtServer,completed: @escaping(_ dataResult : DataResult&lt;Dictionary&lt;String, Any&gt;&gt;) -&gt; Void) -&gt; URLSessionTask?
</code></pre>

<p>至于为什么定义成这样子,我一个参数一个参数的解释,其实解释完了,这篇博客也就差不多了.</p>

<h6 id="toc_2">首先第一个参数interface: URLConfig</h6>

<p>URLConfig是一个协议.内容很简单</p>

<pre><code>protocol URLConfig{
    func getPath() -&gt; String
}
</code></pre>

<p>就只有一个<code>getPath</code>的方法,目的是获取接口的url路径,有人会说,那为什么要定义一个协议呢?直接一个<code>String</code>类型不就可以了吗?这样做有一个好处,大家有没有发现,让你直接调用Alamofire的时候,可以传String,也可以传URL,都可以,因为它的类型也是一个协议呀,String和URL都实现了这个协议就ok拉,所以我也是这样做的.其实就是面向对象中的多态.</p>

<h6 id="toc_3">接口的管理</h6>

<p>在项目中我是用枚举关联String管理接口的,这样的好处是接口统一在一个位置,清晰,易扩展,好维护.<br/>
<img src="media/15017218903153/15018108531635.jpg" alt=""/><br/>
枚举同样也实现了URLConfig协议,在调用网络接口的时候,第一个参数只需要填入<code>InterfaceEnum.devAuth</code>就可以了,可能有朋友会有疑问,基本每个公司开发接口,测试接口,正式接口,有的时候你们公司对接别的服务器,还有有不同的协议,比如你们用https他们用http的情况,切换环境,我用一个全局变量就ok了,就是NetConfig.curServerIP,只要把curServerIP换了,环境也就切换了,但是一部分用http,另一部分用https,或有的时候你和同事联调,100个接口有10个跑他的ip,90个跑服务器的,怎么办呢?其实很简单,这就体现了协议的好处,你在建一个<code>InterfaceXXXXEnum</code>,再实现一个getPath协议,这次你可以拼接成https://  也可以拼接成ftp的都可以了,这样做之后,你会发现,你的接口管理的很清晰,那个接口是http的  哪个是https的,哪个是XXX的,一看就知道了,统一了管理.</p>

<h6 id="toc_4">第二个参数是接口中需要的参数,这个没啥好说的</h6>

<h6 id="toc_5">第三个是请求的方式</h6>

<p>是GET还是POST,按理说这个也没啥好说的,但是有一点我希望在这里说明,也就是我上文我说的之后我会说的,由于我们用的是AlamoFire,他有自己的请求类型枚举<br/>
<img src="media/15017218903153/15018121396577.jpg" alt=""/><br/>
但是我不想用它,因为我们进行二次封装的目的是什么,是隔离,不想让他对项目有太多的入侵,所以这也是我建这个中间层的第二个目的,在中间层,把所有数据转换成Foundation框架的基本类型,传递给Alamofire,这样,后期无论怎么换,只要有Foundation在,我的框架就不由会大问题.所以我自己也建了一个枚举跟上面的枚举差不多,只不过区别是他是他的,我是我的~~.<br/>
<img src="media/15017218903153/15018126056939.jpg" alt=""/></p>

<h6 id="toc_6">第四个参数,serverType</h6>

<p>在实际开发中,有很多时候你对接的不是一个服务器,比如美团,微信,阿里他的项目中嵌入了好多别人的项目,虽然这些项目的网络请求会在自己的sdk中解决,但是难免会出现一个项目跑两个服务器的情况,就像我们公司海底捞重构的项目,前端和后端一起重构,但是前端之前有过UI重构的经验了,所以写起来要比后端快的多,所以我们在重构的时候大部分还是用的老接口,这时候,有个后端的大哥说,那个我这几个接口做好了,你试试吧,但是他的这几个接口是有前置条件了,但这些前置条件在新的服务器中还没有实现,这时候你就需要前置接口调用老服务器,新接口调用新服务器,不同的服务器,加密解密方式,数据的拼接要求肯定是不同的,所以我就又造了一个枚举,<code>ServerType</code><br/>
<img src="media/15017218903153/15018134572100.jpg" alt=""/><br/>
有个这个枚举之后,就可以根据不用的服务器,做不同的加密,数据返回后做不同的解析了.</p>

<h6 id="toc_7">然后就是最后一个参数了,回调函数.</h6>

<p>这个回调函数其实也没什么说的,但是我对数据做了一层封装,就是DataResult的数据类型,至于为什么,我的Swift的一种常用类型那篇博文里有说明,大家可以去看看.</p>

<h6 id="toc_8">最后作为一个网络请求,你的返回值是什么</h6>

<p>它是什么,取决你要拿它干嘛用,很多时候,在轮询的场景下,一个请求没完成,不能发起下一个请求,或是把上一个请求取消,所以我就把<code>URLSessionTask</code>返回了,其实Alamofire也有自己的Task,但是我还是坚持返回了<code>Foundation</code>框架里的类型,至于为啥就不多说了.</p>

<h4 id="toc_9">3核心的实现</h4>

<p>网络核心层当然后调用Alamofire了,这部分就比较简单了.在这之前,先看下上面讲的接口的实现.<br/>
<img src="media/15017218903153/15018136557339.jpg" alt=""/><br/>
default就是核心层的单例</p>

<pre><code>private static let `default` : RequestManagerProtocol = RequestManager()
</code></pre>

<p><img src="media/15017218903153/15018138410087.jpg" alt=""/><br/>
这一层中,还是一个协议,保证了接口的统一,如果有换库等行为,只要实现了这个协议,就可以保证对外暴露的接口不变.        </p>

<h4 id="toc_10">业务层的调用</h4>

<p>尽管我们接口中有很多参数,但是大部分都有默认参数,所以大部分情况下,业务端是不需要知道全部参数的,他只需要知道两个参数,一个是接口地址,一个是要传的参数</p>

<pre><code>NetRequest.request(withInterface: InterfaceEnum.cashNeedMoney, requestData: params) { (data) in
            switch data {
            case .failure(let error):
                complete(DataResult.failure(error))
            case .success(let value):
                let money = (value[&quot;DATA&quot;] as? NSNumber) ?? 0
                complete(DataResult.success(money))
            }
        }
</code></pre>

<p>仅此而已,这就够了.</p>

<h4 id="toc_11">思考</h4>

<p>到目前为止,我的这个封装完全满足了项目的需求,但是也有在考虑要不要增加返回数据的类型,现在我只支持返回字典,但是这样做我也是有自己的想法的,因为一个项目业务端的解析方式大都很固定,我给他们暴露了太多的接口,反而会导致业务端调用的混乱,毕竟我是二次封装,如果写的太多了,就不是二次封装了.下一篇博客,我会分析Alamofire的源码,并提出我的疑惑,欢迎来撕~</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中对于有先后顺序的网络请求的优化]]></title>
    <link href="https://rookieneo.github.io/15008764200399.html"/>
    <updated>2017-07-24T14:07:00+08:00</updated>
    <id>https://rookieneo.github.io/15008764200399.html</id>
    <content type="html"><![CDATA[
<p>在实际开发中会有很多场景是需要发送多个网络请求的,并且它们之间有逻辑关系,比如餐厅APP中,用户需要先确认账单才能打印账单,并且是确认账单成功了才能打印账单,对于这种问题有几种解决方法:</p>

<h4 id="toc_0">1让后端的大哥改下</h4>

<p>也就是说你可以找你的后端让他帮你在确认账单接口调用的时候调用下打印账单的方法,说实话以前我真的喜欢这么干,但是后来我发现我错了,因为这样做两个业务就耦合在一起了,如果以后还有人要调用这个接口,他绝对想不到这个接口还会触发打印.所以这不是一个好办法.</p>

<h4 id="toc_1">2嵌套调用</h4>

<p><img src="media/15008764200399/15008775374587.jpg" alt=""/></p>

<p>这是我最开始写的代码,我在调用确认账单,并且返回成功了之后,又调用了打印账单.这样做看似是可以了,但是不够好,因为这才两个请求,如果有四五请求有这种业务上的需求,嵌套在一起就回显得很乱,比如:<br/>
<img src="media/15008764200399/15008777031048.jpg" alt=""/></p>

<p>相信在你看到这种网络请求的时候各种各样的回调的时候,你是绝望的.它很不清晰,把闭包的缺点表现的淋漓尽致.所以这个方法也不好,但它是可用的.</p>

<h4 id="toc_2">3依赖队列</h4>

<p><img src="media/15008764200399/15008778898419.jpg" alt=""/></p>

<p>这是我使用队列最初的想法,首先这两个网络请求是串行的,我的想法是用依赖,printOp依赖于makeSureOp,也就是说只有当确认账单的请求执行完了之后,才会调用打印的接口.事物总是看似美好,其实并没有这么简单.这中队列是不行的,原因有两点,第一点,第一个任务无论最后是成功还是失败,都会调用打印任务,这样是不符合业务.第二点因为网络请求是异步的,所以这个依赖的添加是无效的,第一个任务的网络请求还没有返回,第二个就已经开始了,这个位置我也不是特别理解,为什么依赖是能在同一线程中起作用.</p>

<h4 id="toc_3">优化队列</h4>

<p><img src="media/15008764200399/15008784802926.jpg" alt=""/></p>

<p>这是我优化之后的方法.首先向队列中添加一个确认账单的任务,在成功之后再向队列中添加打印任务.这样做之后,业务实现了,代码也清晰了,就有4 5个有顺序的请求,也很清晰,只需要在成功的地方向队列中添加任务就可以了.<br/>
总结:<br/>
    在实际开发中,这种需求有别于批量下载图片的需求,因为批量下载图片任务之间并没有业务关系,你完全可以建一个GCD的组,每一次下载图片的时候都向组里添加任务,当组中的任务都完成的之后,就是所有图片都下载完了,就算下载不成功,对后续的任务也不会有影响.但是它解决不了接口和接口直接有业务关系的问题,因为下载图片,每个任务都是独立的,异步的,但是这个问题,所有的请求其实是串行的,同步的,有关系的.所以我采用的这种方法来实现,具体怎么样,还需要实践.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Whats-new-in-swift-4 (下)]]></title>
    <link href="https://rookieneo.github.io/14970555001135.html"/>
    <updated>2017-06-10T08:45:00+08:00</updated>
    <id>https://rookieneo.github.io/14970555001135.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">Dictionary and Set enhancements</h4>

<p>关于字典的改进都是很直观的.</p>

<pre><code>let names = [&quot;Cagney&quot;, &quot;Lacey&quot;, &quot;Bensen&quot;]
let dict = Dictionary(uniqueKeysWithValues: zip(1..., names))
//print [2: &quot;Lacey&quot;, 3: &quot;Bensen&quot;, 1: &quot;Cagney&quot;]
dict[2]
print Lacey
//
</code></pre>

<pre><code>let contacts = [&quot;Julia&quot;, &quot;Susan&quot;, &quot;John&quot;, &quot;Alice&quot;, &quot;Alex&quot;]
let grouped = Dictionary(grouping: contacts, by: { $0.first! })
grouped
//print [&quot;J&quot;: [&quot;Julia&quot;, &quot;John&quot;], &quot;S&quot;: [&quot;Susan&quot;], &quot;A&quot;: [&quot;Alice&quot;, &quot;Alex&quot;]]
</code></pre>

<p>很多时候服务器返回的JSON并不会给你分组,但是很有需求是需要在list中分组的,这个方法是很好的.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Whats-new-in-swift-4 (上)]]></title>
    <link href="https://rookieneo.github.io/14969065461458.html"/>
    <updated>2017-06-08T15:22:26+08:00</updated>
    <id>https://rookieneo.github.io/14969065461458.html</id>
    <content type="html"><![CDATA[
<p>Swift4终于到4了,这次升级对之前的版本有很好的兼容,而且也有一些很不错的API<br/>
于是我是看了 Ole Begemann这位外国友人的github的Swift4的playground<a href="https://github.com/ole/whats-new-in-swift-4">传送门</a>总结了一下,这种东西,还是老外搞得好,国内真的不行...</p>

<h4 id="toc_0">Strings</h4>

<ol>
<li>第一个就是String,增加了<code>&quot;&quot;&quot;</code>这个功能
栗子:</li>
</ol>

<pre><code class="language-swift">let multilineString = &quot;&quot;&quot;
        This is a multi-line string.
    You don&#39;t have to escape &quot;quotes&quot; in here.
    The position of the closing delimiter
      controls whitespace stripping
    &quot;&quot;&quot;
print(multilineString)
</code></pre>

<p>打印出来的效果是这个样子的<br/>
<img src="media/14969065461458/14969075270793.jpg" alt=""/><br/>
没错,就是和你在代码里写的空行一模一样,不需要打换行符和空格了,不知道大家觉得如何,我是觉得非常好,因为...<br/>
<img src="media/14969065461458/14969077073633.jpg" alt=""/><br/>
我只是为了让网络请求的打印的日志好看一点,把代码写成这样也是很蓝瘦的,不过现在有&quot;&quot;&quot;就好了<br/>
2. String终于有.count了 不容易,而且取subString什么的更容易了,我自己项目里的String的extension终于可以去掉了,人家写的确实比我好,嘿嘿</p>

<pre><code class="language-swift">let greeting = &quot;Hello, 😜!&quot;
let comma = greeting.index(of: &quot;,&quot;)!
let substring = greeting[..&lt;comma]
//print Hello
</code></pre>

<h4 id="toc_1">SubScripts</h4>

<p>1.<br/>
这个不用说,秒懂,感觉还好,以前用着也不费劲</p>

<pre><code class="language-swift">let numbers = [1,2,3,4,5,6,7,8,9,10]
numbers[5...] // instead of numbers[5..&lt;numbers.endIndex]
//print Hello
</code></pre>

<h4 id="toc_2">Private declarations visible in same-file extensions</h4>

<p>同一个文件下的Extensions中用到的Private属性可以不用改为filePrivate了,这个改动很好,因为同一个文件下的类的扩展,本身就同一个类,为什么我在类的方法中调用自己的属性,还需要用fileprivate,就很奇怪,当初我用的时候就感觉很难受,一使用extension就需要改权限...<br/>
<img src="media/14969065461458/14969090403987.jpg" alt=""/><br/>
如果在swift3中,stroage这个属性是要改成fileprivate的.</p>

<h4 id="toc_3">Key Paths</h4>

<p><img src="media/14969065461458/14969097853215.jpg" alt="" style="width:1860px;"/></p>

<pre><code class="language-swift">sicp[keyPath: \Book.title]
sicp.title
//print same Structure and Interpretation of Computer Programs
sicp[keyPath: \Book.title]
sicp[keyPath: \Book.primaryAuthor.name]
//print Harold Abelson
</code></pre>

<p>结构体中的属性可以像路径一样被取出<br/>
当然也可以拼接路径 就像这样</p>

<pre><code class="language-Swfit">let authorKeyPath = \Book.primaryAuthor
type(of: authorKeyPath)
let nameKeyPath = authorKeyPath.appending(path: \.name) // you can omit the type name if the compiler can infer it
sicp[keyPath: nameKeyPath]
//print  Harold Abelson
</code></pre>

<p>虽然我现在也不是太理解这样好处,但是能感觉出来这个一个很重大的改进,很多大神都可能会在这做文章,期待.</p>

<h4 id="toc_4">Encoding and decoding 重头戏</h4>

<p>这个是已经被公认的一个重大的提升,先举栗子</p>

<p><img src="media/14969065461458/14969104547178.jpg" alt=""/><br/>
这是一个结构体,有一点特殊,它遵循了Codable协议,hand数组中初始化了两个Card.<br/>
然后~<br/>
Encoding</p>

<pre><code class="language-Swfit">var encoder = JSONEncoder()

// Properties offered by JSONEncoder to customize output
encoder.dataEncodingStrategy
encoder.dateEncodingStrategy
encoder.nonConformingFloatEncodingStrategy
encoder.outputFormatting
encoder.userInfo

let jsonData = try encoder.encode(hand)
String(data: jsonData, encoding: .utf8)
//print &quot;[{\&quot;rank\&quot;:1,\&quot;suit\&quot;:\&quot;clubs\&quot;},{\&quot;rank\&quot;:12,\&quot;suit\&quot;:\&quot;hearts\&quot;}]&quot;
//你没有看错  它是JSON了
</code></pre>

<p>Decoding</p>

<pre><code class="language-Swift">let decoder = JSONDecoder()
let decoded = try decoder.decode([Card].self, from: jsonData)
// decoder 现在和截图中hand是一模一样的了666
</code></pre>

<p>系统的API帮我们做了json解析,这是非常好的.<br/>
结构体是值类型,适用于单向数据流的数据传输方式,不过移动端的数据流一般都是双向的,意思就是你引用了别人的model,你把model中的数据给改了,那别人的model对应的数据也改了,因为大家的model用的都是类,而不是结构体,是引用类型,这样做在移动端是很方便的,但是也有很多弊端,比如你改了别人的数据,但是那哥们却不知道,这是很危险的,如果项目比较大,这老哥就为了知道是谁改了他数据就能找半天,但是结构体是值类型,就不会有这个问题,因为每次赋值,都是一个新的,这样就很安全,但是你每次改数据都需要调用别人的接口,这样就会很繁琐,而且数据的一致性和保持不了,在web前端有流行的框架中,react,vue(排名不分先后)都是单向数据,但是他们也有双向绑定的机制,也有很好的框架保证数据的准确.移动端这样的框架也有,只不过没有流行起来<br/>
所以我就测试了一下类是不是也可以这样搞,结果是可以,皆大欢喜,引用类型也可以遵循Codable协议,来实现和JSON数据的互转.</p>

<h4 id="toc_5">Generic subscripts 角标方法中可以使用泛型了</h4>

<p>这是一个很好的消息,这会使得subscripts的使用变得更广泛,更已用,我在之前封装的UserDefaults方法中就因为角标方法中不能使用泛型限制了我的思路,现在终于可以实现了. </p>

<pre><code class="language-Swift">subscript&lt;T&gt;(key: String) -&gt; T? {
        return storage[key] as? T
    }
</code></pre>

<p>相信用过subscipt方法的看到这个栗子会很激动,没用过的,也感受不到Swift3中不能使用泛型的困扰了</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中对UserDefaults的封装]]></title>
    <link href="https://rookieneo.github.io/14956811508929.html"/>
    <updated>2017-05-25T10:59:10+08:00</updated>
    <id>https://rookieneo.github.io/14956811508929.html</id>
    <content type="html"><![CDATA[
<p>Founddation中UserDefaults是一种很轻量化的本地化工具,实际开发中经常会使用,由于苹果中很多类库还没有用Swift重写,所以在Swift中用UserDefaults就显示不是很Swift,还是OC的感觉,所以我就想对UserDefaults进行一次封装,让它更Swift,用起来更方便.我最早由这种想法实在Swift2的时候,那时候就感觉用起来不是很方便了,但是没有多想,之后又看到了一篇文章<a href="http://radex.io/swift/nsuserdefaults/">传送门</a>,它是用Swift中subscript的方法对NSUserDefaults进行了封装,Swift中,Dic[key],Array[index],都是使用了subscript方法.我就是参照这位外国友人的思路进行了封装.</p>

<h2 id="toc_0">[subscript] + 泛型 的方式</h2>

<p>这是我最开始的设计思路,先看代码 ...有时间在更新吧 先到这里</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift的一种常用类型]]></title>
    <link href="https://rookieneo.github.io/14936932217611.html"/>
    <updated>2017-05-02T10:47:01+08:00</updated>
    <id>https://rookieneo.github.io/14936932217611.html</id>
    <content type="html"><![CDATA[
<p><img src="media/14936911497977/14936911882116.jpg" alt=""/></p>

<h6 id="toc_0">这是我在公司项目用到的一种用于网络请求返回数据的类型,我第一次见到它是Alamofire的源码中,他对网络请求的数据就进行了一种这样的封装,当时就觉得不错,不过并没有在意,后来又在喵神翻译的swift进阶中又看了,于是就抱着试一试的态度用一下,果然效果还是不错的.</h6>

<h5 id="toc_1">我个人认为这是一个加强版的可选类型,其实可选类型就是一个枚举值,有value和nil两个枚举值,这个DataResult也是一个枚举值,有error和value两种枚举值,区别是可选类型对返回时nil的情况并不在意,更在意的是结果,只要告诉我有或者没有就可以了,而DataResult类型比可选类型更重视返回错误时的情况,所以我觉得这很适合用在网络请求的返回值中,有数据的时候就是成功,没有数据的时候就是失败,失败的时候返回error类型给业务层做相应的处理.</h5>

<p><img src="media/14936911497977/14936925384241.jpg" alt=""/><br/>
这是业务层的使用情况,data就是DataResult类型,也可以使用if else 还做处理,这就是extension中isSuccess和isFailure的作用.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[按钮加下拉弹框控件的封装]]></title>
    <link href="https://rookieneo.github.io/14924176125873.html"/>
    <updated>2017-04-17T16:26:52+08:00</updated>
    <id>https://rookieneo.github.io/14924176125873.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">直接上图</h4>

<p><img src="media/14924176125873/1F2A7756-BAA8-4521-8122-3C2F3C180AD5.png" alt="1F2A7756-BAA8-4521-8122-3C2F3C180AD5"/><br/>
由于项目里用到好多这种点击上面的按钮,下拉出一个tableView弹框的需求,所以我决定单独封装一个.</p>

<h4 id="toc_1">需求和思路</h4>

<ol>
<li>需求:点击上面的按钮,弹出一个下拉框,点击下拉框中的cell,tableView消失,按钮刷新为选中的cell.</li>
<li>思路:因为有些地方用上面的按钮控件,有些地方只用下面的控件,有些地方又两个要在一起用,所以我决定封装两个简单的View控件,在单独封装一个View,将两个控件做到一起.</li>
</ol>

<h4 id="toc_2">Go!</h4>

<ol>
<li>封装按钮控件</li>
</ol>

<p><img src="media/14924176125873/WechatIMG243.jpeg" alt="WechatIMG243"/></p>

<p>既然是封装,那么这个按钮的宽度就一定不能是死的,所以我决定只设置红色位置的layout,整体控件的宽度由&quot;班次&quot;&quot;全部&quot;两个Label和图片撑开,传入的String多宽控件就多宽.<br/>
   UI的问题解决了,剩下的就是如何初始化和配置还有时间传递的问题了,首先要使用这个控件就必须有两个参数,就是两个String,所以我在初始化方法中添加两个参数,而例如两个Label的颜色这种数据作为public属性,可配置.当然还需要两个get set方法的属性,用于初始化控件后,改变控件上的文字,so,控件的初始化方法和暴露的属性是这个样子的:<br/>
   <img src="media/14924176125873/WechatIMG247.jpeg" alt="WechatIMG247" style="width:572px;"/><br/>
图中代码上面的初始化的方法和属性,两个Public属性的get和set方法是用于读和设置label的,之所以这么做是因为我觉得分装的控件不应该暴露出UIlabel这种东西(个人想法)所以我用了这种方法对label做了一层处理而真正的label是private的.还有一点要说的是第二个框的代码,我构建UI的位置是在viewdidMovetoSuperView中的时候,是因为放在初始化中会导致设置的字体颜色无效,因为给label设置颜色的位置在configUI方法中.在初始化中调用会导致先调用了configUI,然后才给left or right Color 赋值.点击的事件我选择用代理方法,参数是btn选中的状态ture or false.<br/>
2. 封装下拉控件<br/>
<img src="media/14924176125873/14924213229065.jpg" alt=""/><br/>
下拉控件中,我是暴露了一个属性,就是tableView每一个行的高度,初始化中,必须传入tableView的数据.并设置了tableView的阴影,因为项目里的这个控件都需要有阴影,如果其他项目不需要其实可以暴露一个bool属性,控制一下阴影效果.<br/>
<img src="media/14924176125873/14924214894815.jpg" alt=""/></p>

<ol>
<li>将两个控件封装成一个控件
<img src="media/14924176125873/14924215554777.jpg" alt=""/></li>
</ol>

<p>这是我封装的新控件的所有暴露的方法,我会一个个的解释这个写的目的,首先第一个属性,isAppeared属性,在每次set之后都会判断它的值,如果是true就创建下拉tableView的控件,如果是false就删除.现在didset中的目的就是配合第一个按钮的控件<br/>
<img src="media/14924176125873/14924217419848.jpg" alt=""/><br/>
这是按钮控件的代理方法的实现,在这个代理方法中,我只需要改变一下isAppear的值就可以控制显示隐藏,而isAppear的值就是按钮控件通过代理方法传给我的值,可能有朋友会觉得那把isAppeard里的代码放到按钮控件的代理方法不也一样么,这个地方我的想法是下拉控件的显示和隐藏不应该是有控件的内部可以控制,如果我点出了拉下控件,用户点击别的位置,按照用户习惯,这个弹框应该收起,所以我才写了isAppeared这个属性,这样以来,外部和内部都可以控制下拉控件的显示和隐藏.<br/>
剩下的pullDownHeight和listViewHeight属性是用来控制整个控件的高度和下拉控件的高度的,至于为什么没有暴露出设置宽度的属性,是因为我觉觉得这个控件既然是两个控件的融合,那么下拉框的宽度因为和按钮控件保持一致,而按钮控件的宽度又是由里面的title决定的,所以我没有暴露出宽度的属性.<br/>
<img src="media/14924176125873/14924223637448.jpg" alt=""/><br/>
最后实现拉下控件的代理方法,根据用户点击的cell改变按钮控件的rightLabel的text,当然也是通过修改按钮控件暴露的rightText属性的set方法,而不是直接修改Label的方式.个人认为比较优雅一下,直接改label感觉很暴力.最后在将点击的时间传在control层,分别将点击的index和title传出,方便使用者根据用户的点击做出响应.</p>

<h4 id="toc_3">总结</h4>

<p>其实这个控件的分装没有太大的难度,我自己觉得通过这次封装,一是将两个控件封装到一起,并且其中任何一个控件又都可以单独拿出来用的这种封装方式有了一定的认识,二是如何封装出优雅的可用的控件,不该暴露的属性就不要多暴露,让使用者一目了然,初始化的方法参数能少则少,参数越多,使用难度越大,一起不必要的参数都设置为有默认值可配置的形式.<br/>
代码我会在稍后传到我的github上<br/>
<a href="https://github.com/RookieNeo">传送门</a></p>

]]></content>
  </entry>
  
</feed>
