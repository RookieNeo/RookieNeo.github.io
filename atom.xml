<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[RookieNeo]]></title>
  <link href="https://rookieneo.github.io/atom.xml" rel="self"/>
  <link href="https://rookieneo.github.io/"/>
  <updated>2017-07-24T14:51:27+08:00</updated>
  <id>https://rookieneo.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift中对于有先后顺序的网络请求的优化]]></title>
    <link href="https://rookieneo.github.io/15008764200399.html"/>
    <updated>2017-07-24T14:07:00+08:00</updated>
    <id>https://rookieneo.github.io/15008764200399.html</id>
    <content type="html"><![CDATA[
<p>在实际开发中会有很多场景是需要发送多个网络请求的,并且它们之间有逻辑关系,比如餐厅APP中,用户需要先确认账单才能打印账单,并且是确认账单成功了才能打印账单,对于这种问题有几种解决方法:</p>

<h4 id="toc_0">1让后端的大哥改下</h4>

<p>也就是说你可以找你的后端让他帮你在确认账单接口调用的时候调用下打印账单的方法,说实话以前我真的喜欢这么干,但是后来我发现我错了,因为这样做两个业务就耦合在一起了,如果以后还有人要调用这个接口,他绝对想不到这个接口还会触发打印.所以这不是一个好办法.</p>

<h4 id="toc_1">2嵌套调用</h4>

<p><img src="media/15008764200399/15008775374587.jpg" alt=""/></p>

<p>这是我最开始写的代码,我在调用确认账单,并且返回成功了之后,又调用了打印账单.这样做看似是可以了,但是不够好,因为这才两个请求,如果有四五请求有这种业务上的需求,嵌套在一起就回显得很乱,比如:<br/>
<img src="media/15008764200399/15008777031048.jpg" alt=""/></p>

<p>相信在你看到这种网络请求的时候各种各样的回调的时候,你是绝望的.它很不清晰,把闭包的缺点表现的淋漓尽致.所以这个方法也不好,但它是可用的.</p>

<h4 id="toc_2">3依赖队列</h4>

<p><img src="media/15008764200399/15008778898419.jpg" alt=""/></p>

<p>这是我使用队列最初的想法,首先这两个网络请求是串行的,我的想法是用依赖,printOp依赖于makeSureOp,也就是说只有当确认账单的请求执行完了之后,才会调用打印的接口.事物总是看似美好,其实并没有这么简单.这中队列是不行的,原因有两点,第一点,第一个任务无论最后是成功还是失败,都会调用打印任务,这样是不符合业务.第二点因为网络请求是异步的,所以这个依赖的添加是无效的,第一个任务的网络请求还没有返回,第二个就已经开始了,这个位置我也不是特别理解,为什么依赖是能在同一线程中起作用.</p>

<h4 id="toc_3">优化队列</h4>

<p><img src="media/15008764200399/15008784802926.jpg" alt=""/></p>

<p>这是我优化之后的方法.首先向队列中添加一个确认账单的任务,在成功之后再向队列中添加打印任务.这样做之后,业务实现了,代码也清晰了,就有4 5个有顺序的请求,也很清晰,只需要在成功的地方向队列中添加任务就可以了.<br/>
总结:<br/>
    在实际开发中,这种需求有别于批量下载图片的需求,因为批量下载图片任务之间并没有业务关系,你完全可以建一个GCD的组,每一次下载图片的时候都向组里添加任务,当组中的任务都完成的之后,就是所有图片都下载完了,就算下载不成功,对后续的任务也不会有影响.但是它解决不了接口和接口直接有业务关系的问题,因为下载图片,每个任务都是独立的,异步的,但是这个问题,所有的请求其实是串行的,同步的,有关系的.所以我采用的这种方法来实现,具体怎么样,还需要实践.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Whats-new-in-swift-4 (下)]]></title>
    <link href="https://rookieneo.github.io/14970555001135.html"/>
    <updated>2017-06-10T08:45:00+08:00</updated>
    <id>https://rookieneo.github.io/14970555001135.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">Dictionary and Set enhancements</h4>

<p>关于字典的改进都是很直观的.</p>

<pre><code>let names = [&quot;Cagney&quot;, &quot;Lacey&quot;, &quot;Bensen&quot;]
let dict = Dictionary(uniqueKeysWithValues: zip(1..., names))
//print [2: &quot;Lacey&quot;, 3: &quot;Bensen&quot;, 1: &quot;Cagney&quot;]
dict[2]
print Lacey
//
</code></pre>

<pre><code>let contacts = [&quot;Julia&quot;, &quot;Susan&quot;, &quot;John&quot;, &quot;Alice&quot;, &quot;Alex&quot;]
let grouped = Dictionary(grouping: contacts, by: { $0.first! })
grouped
//print [&quot;J&quot;: [&quot;Julia&quot;, &quot;John&quot;], &quot;S&quot;: [&quot;Susan&quot;], &quot;A&quot;: [&quot;Alice&quot;, &quot;Alex&quot;]]
</code></pre>

<p>很多时候服务器返回的JSON并不会给你分组,但是很有需求是需要在list中分组的,这个方法是很好的.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Whats-new-in-swift-4 (上)]]></title>
    <link href="https://rookieneo.github.io/14969065461458.html"/>
    <updated>2017-06-08T15:22:26+08:00</updated>
    <id>https://rookieneo.github.io/14969065461458.html</id>
    <content type="html"><![CDATA[
<p>Swift4终于到4了,这次升级对之前的版本有很好的兼容,而且也有一些很不错的API<br/>
于是我是看了 Ole Begemann这位外国友人的github的Swift4的playground<a href="https://github.com/ole/whats-new-in-swift-4">传送门</a>总结了一下,这种东西,还是老外搞得好,国内真的不行...</p>

<h4 id="toc_0">Strings</h4>

<ol>
<li>第一个就是String,增加了<code>&quot;&quot;&quot;</code>这个功能
栗子:</li>
</ol>

<pre><code class="language-swift">let multilineString = &quot;&quot;&quot;
        This is a multi-line string.
    You don&#39;t have to escape &quot;quotes&quot; in here.
    The position of the closing delimiter
      controls whitespace stripping
    &quot;&quot;&quot;
print(multilineString)
</code></pre>

<p>打印出来的效果是这个样子的<br/>
<img src="media/14969065461458/14969075270793.jpg" alt=""/><br/>
没错,就是和你在代码里写的空行一模一样,不需要打换行符和空格了,不知道大家觉得如何,我是觉得非常好,因为...<br/>
<img src="media/14969065461458/14969077073633.jpg" alt=""/><br/>
我只是为了让网络请求的打印的日志好看一点,把代码写成这样也是很蓝瘦的,不过现在有&quot;&quot;&quot;就好了<br/>
2. String终于有.count了 不容易,而且取subString什么的更容易了,我自己项目里的String的extension终于可以去掉了,人家写的确实比我好,嘿嘿</p>

<pre><code class="language-swift">let greeting = &quot;Hello, 😜!&quot;
let comma = greeting.index(of: &quot;,&quot;)!
let substring = greeting[..&lt;comma]
//print Hello
</code></pre>

<h4 id="toc_1">SubScripts</h4>

<p>1.<br/>
这个不用说,秒懂,感觉还好,以前用着也不费劲</p>

<pre><code class="language-swift">let numbers = [1,2,3,4,5,6,7,8,9,10]
numbers[5...] // instead of numbers[5..&lt;numbers.endIndex]
//print Hello
</code></pre>

<h4 id="toc_2">Private declarations visible in same-file extensions</h4>

<p>同一个文件下的Extensions中用到的Private属性可以不用改为filePrivate了,这个改动很好,因为同一个文件下的类的扩展,本身就同一个类,为什么我在类的方法中调用自己的属性,还需要用fileprivate,就很奇怪,当初我用的时候就感觉很难受,一使用extension就需要改权限...<br/>
<img src="media/14969065461458/14969090403987.jpg" alt=""/><br/>
如果在swift3中,stroage这个属性是要改成fileprivate的.</p>

<h4 id="toc_3">Key Paths</h4>

<p><img src="media/14969065461458/14969097853215.jpg" alt="" style="width:1860px;"/></p>

<pre><code class="language-swift">sicp[keyPath: \Book.title]
sicp.title
//print same Structure and Interpretation of Computer Programs
sicp[keyPath: \Book.title]
sicp[keyPath: \Book.primaryAuthor.name]
//print Harold Abelson
</code></pre>

<p>结构体中的属性可以像路径一样被取出<br/>
当然也可以拼接路径 就像这样</p>

<pre><code class="language-Swfit">let authorKeyPath = \Book.primaryAuthor
type(of: authorKeyPath)
let nameKeyPath = authorKeyPath.appending(path: \.name) // you can omit the type name if the compiler can infer it
sicp[keyPath: nameKeyPath]
//print  Harold Abelson
</code></pre>

<p>虽然我现在也不是太理解这样好处,但是能感觉出来这个一个很重大的改进,很多大神都可能会在这做文章,期待.</p>

<h4 id="toc_4">Encoding and decoding 重头戏</h4>

<p>这个是已经被公认的一个重大的提升,先举栗子</p>

<p><img src="media/14969065461458/14969104547178.jpg" alt=""/><br/>
这是一个结构体,有一点特殊,它遵循了Codable协议,hand数组中初始化了两个Card.<br/>
然后~<br/>
Encoding</p>

<pre><code class="language-Swfit">var encoder = JSONEncoder()

// Properties offered by JSONEncoder to customize output
encoder.dataEncodingStrategy
encoder.dateEncodingStrategy
encoder.nonConformingFloatEncodingStrategy
encoder.outputFormatting
encoder.userInfo

let jsonData = try encoder.encode(hand)
String(data: jsonData, encoding: .utf8)
//print &quot;[{\&quot;rank\&quot;:1,\&quot;suit\&quot;:\&quot;clubs\&quot;},{\&quot;rank\&quot;:12,\&quot;suit\&quot;:\&quot;hearts\&quot;}]&quot;
//你没有看错  它是JSON了
</code></pre>

<p>Decoding</p>

<pre><code class="language-Swift">let decoder = JSONDecoder()
let decoded = try decoder.decode([Card].self, from: jsonData)
// decoder 现在和截图中hand是一模一样的了666
</code></pre>

<p>系统的API帮我们做了json解析,这是非常好的.<br/>
结构体是值类型,适用于单向数据流的数据传输方式,不过移动端的数据流一般都是双向的,意思就是你引用了别人的model,你把model中的数据给改了,那别人的model对应的数据也改了,因为大家的model用的都是类,而不是结构体,是引用类型,这样做在移动端是很方便的,但是也有很多弊端,比如你改了别人的数据,但是那哥们却不知道,这是很危险的,如果项目比较大,这老哥就为了知道是谁改了他数据就能找半天,但是结构体是值类型,就不会有这个问题,因为每次赋值,都是一个新的,这样就很安全,但是你每次改数据都需要调用别人的接口,这样就会很繁琐,而且数据的一致性和保持不了,在web前端有流行的框架中,react,vue(排名不分先后)都是单向数据,但是他们也有双向绑定的机制,也有很好的框架保证数据的准确.移动端这样的框架也有,只不过没有流行起来<br/>
所以我就测试了一下类是不是也可以这样搞,结果是可以,皆大欢喜,引用类型也可以遵循Codable协议,来实现和JSON数据的互转.</p>

<h4 id="toc_5">Generic subscripts 角标方法中可以使用泛型了</h4>

<p>这是一个很好的消息,这会使得subscripts的使用变得更广泛,更已用,我在之前封装的UserDefaults方法中就因为角标方法中不能使用泛型限制了我的思路,现在终于可以实现了. </p>

<pre><code class="language-Swift">subscript&lt;T&gt;(key: String) -&gt; T? {
        return storage[key] as? T
    }
</code></pre>

<p>相信用过subscipt方法的看到这个栗子会很激动,没用过的,也感受不到Swift3中不能使用泛型的困扰了</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中对UserDefaults的封装]]></title>
    <link href="https://rookieneo.github.io/14956811508929.html"/>
    <updated>2017-05-25T10:59:10+08:00</updated>
    <id>https://rookieneo.github.io/14956811508929.html</id>
    <content type="html"><![CDATA[
<p>Founddation中UserDefaults是一种很轻量化的本地化工具,实际开发中经常会使用,由于苹果中很多类库还没有用Swift重写,所以在Swift中用UserDefaults就显示不是很Swift,还是OC的感觉,所以我就想对UserDefaults进行一次封装,让它更Swift,用起来更方便.我最早由这种想法实在Swift2的时候,那时候就感觉用起来不是很方便了,但是没有多想,之后又看到了一篇文章<a href="http://radex.io/swift/nsuserdefaults/">传送门</a>,它是用Swift中subscript的方法对NSUserDefaults进行了封装,Swift中,Dic[key],Array[index],都是使用了subscript方法.我就是参照这位外国友人的思路进行了封装.</p>

<h2 id="toc_0">[subscript] + 泛型 的方式</h2>

<p>这是我最开始的设计思路,先看代码 ...有时间在更新吧 先到这里</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift的一种常用类型]]></title>
    <link href="https://rookieneo.github.io/14936932217611.html"/>
    <updated>2017-05-02T10:47:01+08:00</updated>
    <id>https://rookieneo.github.io/14936932217611.html</id>
    <content type="html"><![CDATA[
<p><img src="media/14936911497977/14936911882116.jpg" alt=""/></p>

<h6 id="toc_0">这是我在公司项目用到的一种用于网络请求返回数据的类型,我第一次见到它是Alamofire的源码中,他对网络请求的数据就进行了一种这样的封装,当时就觉得不错,不过并没有在意,后来又在喵神翻译的swift进阶中又看了,于是就抱着试一试的态度用一下,果然效果还是不错的.</h6>

<h5 id="toc_1">我个人认为这是一个加强版的可选类型,其实可选类型就是一个枚举值,有value和nil两个枚举值,这个DataResult也是一个枚举值,有error和value两种枚举值,区别是可选类型对返回时nil的情况并不在意,更在意的是结果,只要告诉我有或者没有就可以了,而DataResult类型比可选类型更重视返回错误时的情况,所以我觉得这很适合用在网络请求的返回值中,有数据的时候就是成功,没有数据的时候就是失败,失败的时候返回error类型给业务层做相应的处理.</h5>

<p><img src="media/14936911497977/14936925384241.jpg" alt=""/><br/>
这是业务层的使用情况,data就是DataResult类型,也可以使用if else 还做处理,这就是extension中isSuccess和isFailure的作用.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[按钮加下拉弹框控件的封装]]></title>
    <link href="https://rookieneo.github.io/14924176125873.html"/>
    <updated>2017-04-17T16:26:52+08:00</updated>
    <id>https://rookieneo.github.io/14924176125873.html</id>
    <content type="html"><![CDATA[
<h4 id="toc_0">直接上图</h4>

<p><img src="media/14924176125873/1F2A7756-BAA8-4521-8122-3C2F3C180AD5.png" alt="1F2A7756-BAA8-4521-8122-3C2F3C180AD5"/><br/>
由于项目里用到好多这种点击上面的按钮,下拉出一个tableView弹框的需求,所以我决定单独封装一个.</p>

<h4 id="toc_1">需求和思路</h4>

<ol>
<li>需求:点击上面的按钮,弹出一个下拉框,点击下拉框中的cell,tableView消失,按钮刷新为选中的cell.</li>
<li>思路:因为有些地方用上面的按钮控件,有些地方只用下面的控件,有些地方又两个要在一起用,所以我决定封装两个简单的View控件,在单独封装一个View,将两个控件做到一起.</li>
</ol>

<h4 id="toc_2">Go!</h4>

<ol>
<li>封装按钮控件</li>
</ol>

<p><img src="media/14924176125873/WechatIMG243.jpeg" alt="WechatIMG243"/></p>

<p>既然是封装,那么这个按钮的宽度就一定不能是死的,所以我决定只设置红色位置的layout,整体控件的宽度由&quot;班次&quot;&quot;全部&quot;两个Label和图片撑开,传入的String多宽控件就多宽.<br/>
   UI的问题解决了,剩下的就是如何初始化和配置还有时间传递的问题了,首先要使用这个控件就必须有两个参数,就是两个String,所以我在初始化方法中添加两个参数,而例如两个Label的颜色这种数据作为public属性,可配置.当然还需要两个get set方法的属性,用于初始化控件后,改变控件上的文字,so,控件的初始化方法和暴露的属性是这个样子的:<br/>
   <img src="media/14924176125873/WechatIMG247.jpeg" alt="WechatIMG247" style="width:572px;"/><br/>
图中代码上面的初始化的方法和属性,两个Public属性的get和set方法是用于读和设置label的,之所以这么做是因为我觉得分装的控件不应该暴露出UIlabel这种东西(个人想法)所以我用了这种方法对label做了一层处理而真正的label是private的.还有一点要说的是第二个框的代码,我构建UI的位置是在viewdidMovetoSuperView中的时候,是因为放在初始化中会导致设置的字体颜色无效,因为给label设置颜色的位置在configUI方法中.在初始化中调用会导致先调用了configUI,然后才给left or right Color 赋值.点击的事件我选择用代理方法,参数是btn选中的状态ture or false.<br/>
2. 封装下拉控件<br/>
<img src="media/14924176125873/14924213229065.jpg" alt=""/><br/>
下拉控件中,我是暴露了一个属性,就是tableView每一个行的高度,初始化中,必须传入tableView的数据.并设置了tableView的阴影,因为项目里的这个控件都需要有阴影,如果其他项目不需要其实可以暴露一个bool属性,控制一下阴影效果.<br/>
<img src="media/14924176125873/14924214894815.jpg" alt=""/></p>

<ol>
<li>将两个控件封装成一个控件
<img src="media/14924176125873/14924215554777.jpg" alt=""/></li>
</ol>

<p>这是我封装的新控件的所有暴露的方法,我会一个个的解释这个写的目的,首先第一个属性,isAppeared属性,在每次set之后都会判断它的值,如果是true就创建下拉tableView的控件,如果是false就删除.现在didset中的目的就是配合第一个按钮的控件<br/>
<img src="media/14924176125873/14924217419848.jpg" alt=""/><br/>
这是按钮控件的代理方法的实现,在这个代理方法中,我只需要改变一下isAppear的值就可以控制显示隐藏,而isAppear的值就是按钮控件通过代理方法传给我的值,可能有朋友会觉得那把isAppeard里的代码放到按钮控件的代理方法不也一样么,这个地方我的想法是下拉控件的显示和隐藏不应该是有控件的内部可以控制,如果我点出了拉下控件,用户点击别的位置,按照用户习惯,这个弹框应该收起,所以我才写了isAppeared这个属性,这样以来,外部和内部都可以控制下拉控件的显示和隐藏.<br/>
剩下的pullDownHeight和listViewHeight属性是用来控制整个控件的高度和下拉控件的高度的,至于为什么没有暴露出设置宽度的属性,是因为我觉觉得这个控件既然是两个控件的融合,那么下拉框的宽度因为和按钮控件保持一致,而按钮控件的宽度又是由里面的title决定的,所以我没有暴露出宽度的属性.<br/>
<img src="media/14924176125873/14924223637448.jpg" alt=""/><br/>
最后实现拉下控件的代理方法,根据用户点击的cell改变按钮控件的rightLabel的text,当然也是通过修改按钮控件暴露的rightText属性的set方法,而不是直接修改Label的方式.个人认为比较优雅一下,直接改label感觉很暴力.最后在将点击的时间传在control层,分别将点击的index和title传出,方便使用者根据用户的点击做出响应.</p>

<h4 id="toc_3">总结</h4>

<p>其实这个控件的分装没有太大的难度,我自己觉得通过这次封装,一是将两个控件封装到一起,并且其中任何一个控件又都可以单独拿出来用的这种封装方式有了一定的认识,二是如何封装出优雅的可用的控件,不该暴露的属性就不要多暴露,让使用者一目了然,初始化的方法参数能少则少,参数越多,使用难度越大,一起不必要的参数都设置为有默认值可配置的形式.<br/>
代码我会在稍后传到我的github上<br/>
<a href="https://github.com/RookieNeo">传送门</a></p>

]]></content>
  </entry>
  
</feed>
