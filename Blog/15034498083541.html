<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  对Swift写时复制技术的理解 - RookieNeo
  
  </title>
 <meta name="description" content="学而不思则罔,思而不学则殆">
 <link href="atom.xml" rel="alternate" title="RookieNeo" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">RookieNeo</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; RookieNeo</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>Swift</label></li>

          
            <li><a title="沙漏动画" href="15367255656449.html">沙漏动画</a></li>
          
            <li><a title="关于HTTPS的探究" href="15221395300202.html">关于HTTPS的探究</a></li>
          
            <li><a title="灵活扩展的下拉刷新控件的封装" href="15113233292599.html">灵活扩展的下拉刷新控件的封装</a></li>
          
            <li><a title="对Swift写时复制技术的理解" href="15034498083541.html">对Swift写时复制技术的理解</a></li>
          
            <li><a title="从切圆角引发的对iOS动画框架的探究" href="15026719129123.html">从切圆角引发的对iOS动画框架的探究</a></li>
          
            <li><a title="基于Alamofire网络库的二次封装" href="15017218903153.html">基于Alamofire网络库的二次封装</a></li>
          
            <li><a title="Swift中对于有先后顺序的网络请求的优化" href="15008764200399.html">Swift中对于有先后顺序的网络请求的优化</a></li>
          
            <li><a title="Whats-new-in-swift-4 (下)" href="14970555001135.html">Whats-new-in-swift-4 (下)</a></li>
          
            <li><a title="Whats-new-in-swift-4 (上)" href="14969065461458.html">Whats-new-in-swift-4 (上)</a></li>
          
            <li><a title="Swift中对UserDefaults的封装" href="14956811508929.html">Swift中对UserDefaults的封装</a></li>
          
            <li><a title="Swift的一种常用类型" href="14936932217611.html">Swift的一种常用类型</a></li>
          
            <li><a title="按钮加下拉弹框控件的封装" href="14924176125873.html">按钮加下拉弹框控件的封装</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>Swift</span></li>
                        
                          <li><a title="沙漏动画" href="15367255656449.html">沙漏动画</a></li>
                        
                          <li><a title="关于HTTPS的探究" href="15221395300202.html">关于HTTPS的探究</a></li>
                        
                          <li><a title="灵活扩展的下拉刷新控件的封装" href="15113233292599.html">灵活扩展的下拉刷新控件的封装</a></li>
                        
                          <li><a title="对Swift写时复制技术的理解" href="15034498083541.html">对Swift写时复制技术的理解</a></li>
                        
                          <li><a title="从切圆角引发的对iOS动画框架的探究" href="15026719129123.html">从切圆角引发的对iOS动画框架的探究</a></li>
                        
                          <li><a title="基于Alamofire网络库的二次封装" href="15017218903153.html">基于Alamofire网络库的二次封装</a></li>
                        
                          <li><a title="Swift中对于有先后顺序的网络请求的优化" href="15008764200399.html">Swift中对于有先后顺序的网络请求的优化</a></li>
                        
                          <li><a title="Whats-new-in-swift-4 (下)" href="14970555001135.html">Whats-new-in-swift-4 (下)</a></li>
                        
                          <li><a title="Whats-new-in-swift-4 (上)" href="14969065461458.html">Whats-new-in-swift-4 (上)</a></li>
                        
                          <li><a title="Swift中对UserDefaults的封装" href="14956811508929.html">Swift中对UserDefaults的封装</a></li>
                        
                          <li><a title="Swift的一种常用类型" href="14936932217611.html">Swift的一种常用类型</a></li>
                        
                          <li><a title="按钮加下拉弹框控件的封装" href="14924176125873.html">按钮加下拉弹框控件的封装</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>对Swift写时复制技术的理解</h1>

<p><font color=#5F9EA0 size=3 ></p>

<blockquote>
<p>最近又重新在研究数据结构(<del>当然大学时候学的也不咋地</del>😜)打算把一些经典的数据结构用Swift语言重新实现一遍.虽然在实际开发中,很多高级的数据结构,算法都不需要你来写,我相信每一种语言,都有足够多的框架提供近乎完美的API供你日常开发,这会造成一种幻觉,就是你会觉的这些基础的东西不重要,我理不理解它并不会对我有太大影响,我会调用几个API就足矣.但作为一个coder(其实很多行业也是一样),对基础知识理解的深度,在很大程度上决定了在这条路上你的上限在哪里.<br/>
</font></p>
</blockquote>

<h4 id="toc_0">背景</h4>

<p>其实很早之前我就想仔细的深入的用Swift研究一次数据结构了,但由于一直没有找到好的书籍,这个计划就被挂起了🤕.最近看喵神翻译的新书&lt;&lt;集合类型优化&gt;&gt;出版了<a href="https://objccn.io/products/optimizing-collections/preview/">传送门</a>,借此机会,正好潜心研究一下.<br/>
书中的第一节就提到了写时复制技术,这个词相信使用Swift的开发者都是既熟悉又陌生的.我也听过好多次,在Swift进阶中,我就看到过(<del>写博客的好处之一就是你想把东西讲明白要比你自己看明白深刻好几倍</del>),所以就先研究一下写时复制技术.</p>

<h4 id="toc_1">值类型和引用类型的区别,什么是值语义</h4>

<p>值类型和引用类型的区别这点顺带说一下就行,引用类型的具体表现就是我们最常用的类,通过引用计数来管理,通常我们赋值等操作,只会复制一个指针,指向它所在的内存地址,多一个引用,引用计数就+1,增加了效率,但是不安全(我在<code>Whats new in Swift4</code>这篇博客中的Encoding and decoding中有提到).值类型我们也经常用,Int类型,char,struct都是值类型,将一个值类型变量赋给另一个值类型变量时，将复制包含的值,具有新的内存地址,但这样做是代价是昂贵的(Swift做了优化,后面会解释).<br/>
那什么又是<code>值语义</code>,假设这样的场景,你有一个Class,里面所有的属性(也是引用类型的)都是私有的private,你不想让外部直接用,外部如果需要使用,可以调用暴露的get方法,你把私有属性返回给他,但其实这个时候,这个属性已经不在是私有的了,因为引用类型的特点,外部已经拿到了私有属性的指针,可以对他进行任务操作,很不安全.<br/>
<img src="media/15034498083541/15034528025928.jpg" alt="" style="width:864px;"/><br/>
图中对象b的str改变了,a中的subA对应的属性也跟着改变了.这显然不是你想要效果.需要改造一下,方法也很简单<br/>
<img src="media/15034498083541/15034533452055.jpg" alt=""/><br/>
如果是继承NSObject的类,可以直接用copy来复制.不管怎么说 效果是实现了,它是一个引用类型,但是表现的确实值类型的效果,它就具有了<code>值语义</code>.但很明显这样做的代价是昂贵的,每个get都需要重新创建一个,或复制(深copy)一个,这种消耗是我们不希望存在的.这就需要用到写实复制技术</p>

<h4 id="toc_2">什么是写时复制</h4>

<p><font color=#5F9EA0 size=3 ></p>

<blockquote>
<p>打个比方,你在公司上班,老板说每天给你80块钱,你心里算了算,说行,那一小时就是10块钱,一分钟也就是0.16666667块钱,那老板你每分钟都给我这些钱吧.老板说你小子有病吧,你想累死财务吗(这就是一个无用的消耗)?这钱又飞不了,等你要用的时候(比如你每天下班要吃饭了)我在给你不就完了么,也不耽误你呀.你一想有道理,要不然我还得每天上班带个麻袋装钱,那好吧.这样一种约定就出现了.就是有用的时候在给你,平常只是记录一下<br/>
</font><br/>
简单来说这就是写实复制技术,只有需要改变得时候,才会对变量进行复制,如果不改变,大家都公用一个内存.在 Swift 标准库中，像是 <code>Array</code>，<code>Dictionary</code> 和 <code>Set</code> 这样的集合类型是通过写时复制 (copy-on-write) 的技术实现的(摘录来自: Chris Eidhof. “Swift 进阶”) .所以我们用数组<code>Array</code>举个🌰:<br/>
<img src="media/15034498083541/15034549092312.jpg" alt=""/><br/>
可以看到,尽管数组是值类型,但是在赋值操作之后,内存还是相同的,并没有真正的进行复制.我们改变一下y,在看看:<br/>
<img src="media/15034498083541/15034552504215.jpg" alt=""/><br/>
当y发生改变的时候,y拥有了新的内存地址,它发生了赋值.这就是写时复制技术,昂贵的复制操作只会发生下变量发生改变的时候.这样做后,我们可以保证,我们的数据既是安全的也是高效的.</p>

<h4 id="toc_3">我们需要做什么</h4>

<p>当你的结构体内部都是值类型的时候,写时复制是免费的,但是大部分情况,你的结构体中有一个或多个引用类型,这个时候,写时复制需要你自己来实现了.<br/>
参考Swift进阶中,我们就用<code>NSMutableData</code>举例.<br/>
<img src="media/15034498083541/15034560622792.jpg" alt="" style="width:522px;"/><br/>
在MyData结构体中,data是私有的,我们通过dataForWriting这个计算属性来管理data,每当get操作的时候都会发生复制.并返回data.(在结构体中改变本身需要增加关键字mutating,有个这个关键字只有使用使用var声明的才可以调用).再扩展一个append方法,在调用的时候,dataForWriting会出发get方法,复制一份data,并对成员变量赋值,在对data进行更改.</p>
</blockquote>

<pre><code class="language-Swift">let theData = NSData(base64Encoded: &quot;rookieneo&quot;, options: [])!
var x = MyData(theData)
let y = x
//x.data === y.data true
x.append(x)
//x.data === y.data false
</code></pre>

<p>这样一个基本的写时复制就实现了,在赋值操作的时候,不会发生复制,但是当对变量进行更改的时候,会发生复制.但是这样做,仍然是昂贵的.因为它会在一些不需要复制的时候发生复制,比如:</p>

<pre><code class="language-Swift">let theData = NSData(base64Encoded: &quot;rookieneo&quot;, options: [])!
var x = MyData(theData)
for _ in 0..&lt;5{
    x.append(x)    
}
</code></pre>

<p>很明显,x并没有共享内存,但是复制却一直在发生.这也是我们不希望的.</p>

<h6 id="toc_4">高效方式</h6>

<p>想要不发生上文的无效复制,我们需要知道一件事,就是data属性 是不是唯一引用,在Swift中,<code>isKnownUniquelyReferenced</code>函数(是函数不是方法~)可以来检测是否是唯一引用.但是OC的类这个函数是失效的.所以我们需要对OC的类做一层封装,并对结构体加以改造.<br/>
<img src="media/15034498083541/15034575601593.jpg" alt="" style="width:615px;"/><br/>
这样改造完成后,我们发现,在get方法中,判断一下引用就可以了,只有不唯一的时候才进行复制,这样是极好的😜.只不过那个Swift的泛型封装有点丑陋,不过在swift没有完全摆脱oc的情况下,在所难免.</p>

<pre><code class="language-Swift">var  empty = MyData(NSData())
var emptyCopy = empty
for _ in 0..&lt;5{
    empty.append(theData)
}
</code></pre>

<p>现在再试一下刚才的循环,发现empty只复制了一次,也就是第一次,这样满足了我们的要求,在引用为1的时候不发生复制.到此写时复制的问题就已经解决了.不过在使用时它还有很多陷阱.</p>

<h4 id="toc_5">写时复制的陷阱</h4>

<p>让我们对比来看(伪代码).</p>

<pre><code class="language-Swift">var array = [MyData()]
array[0].append()//No copy
</code></pre>

<pre><code class="language-Swift">var dic = [&quot;rookie&quot;: MyData()]
dic[&quot;rookie&quot;]?.append()//copy
</code></pre>

<p>这看起来很奇怪,都是标准库中的类型,但是表现出来的状态是不同的,在数组下用下标取值不会有多个引用,而字典就会有,看起来数组的表现是正确的,而字典是错误的,那在字典中,我们需要怎么做,让我们来看一下书中的解释.</p>

<blockquote>
<p>如果在你将一个写时复制的结构体放到字典中，又想要避免这种复制的话，你可以将值用类封装起来，这将为值赋予引用语义。</p>

<p>当你在使用自己的结构体时，也需要将这一点牢记于心。比如，我们可以创建一个储存某个值的简单地容器类型，通过直接访问存储的属性，或者间接地使用下标，都可以访问到这个值。当我们直接访问它的时候，我们可以获取写时复制的优化，但是当我们用下标间接访问的时候，复制会发生：</p>
</blockquote>

<pre><code class="language-Swift">struct ContainerStruct&lt;A&gt; {
var storage: A
subscript(s: String) -&gt; A {
get { return storage }
set { storage = newValue }
}
}
var d = ContainerStruct(storage: COWStruct())
d.storage.change() // No copy
d[&quot;test&quot;].change() // Copy”
摘录来自: Chris Eidhof. “Swift 进阶”。 iBooks. 
</code></pre>

<p>居然还需要再用引用类型封装起来,这会让使用者疯掉的,这也是Swift未来的改进方向之一,Swift团队希望字典也表现出和Array一样的效果.之所以数组中是对的,是因为Array是通过地址器(addressors)的方式实现的下标的,地址器会直接访问内存,而不是复制.当然你也可以再自己的代码里实现地址器<a href="https://github.com/apple/swift/blob/73841a643c087e854a2f62c7e073317bd43af310/docs/proposals/Accessors.rst">-传送门-</a></p>

<h2 id="toc_6">总结</h2>

<p><font color=#5F9EA0 size=4 ></p>

<blockquote>
<p>在单向数据流方案非常流行的今天,结构体在Swift中的特性,对单项数据流有着很好的支持,包括reSwift等一些框架都已经有了一席之地,相对于双向数据流,它是安全,可控的,代码也是相对清晰的,所以写时复制的技术也就显得尤为重要,弥补了值类型性能的不足.以后在日常的开发中可以小规模的试用.😜<br/>
</font></p>
</blockquote>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="15113233292599.html"  title="Previous Post: 灵活扩展的下拉刷新控件的封装">&laquo; 灵活扩展的下拉刷新控件的封装</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	        <a href="15026719129123.html" 
	        title="Next Post: 从切圆角引发的对iOS动画框架的探究">从切圆角引发的对iOS动画框架的探究 &raquo;</a>
	    
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://rookieneo.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '15034498083541.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
