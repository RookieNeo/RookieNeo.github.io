<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  数据结构 - RookieNeo
  
  </title>
 <meta name="description" content="">
 <link href="atom.xml" rel="alternate" title="RookieNeo" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">RookieNeo</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; RookieNeo</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>Swift</label></li>

          
            <li><a title="从UTF-8到Bytes数组都经历了什么" href="16164841975946.html">从UTF-8到Bytes数组都经历了什么</a></li>
          
            <li><a title="由一个"Bug"引发的对Swift中Hashable，Equatable原理的探究" href="15972361312490.html">由一个"Bug"引发的对Swift中Hashable，Equatable原理的探究</a></li>
          
            <li><a title="学习SwiftUI两周之后" href="15611299445693.html">学习SwiftUI两周之后</a></li>
          
            <li><a title="沙漏动画" href="15367255656449.html">沙漏动画</a></li>
          
            <li><a title="2018总结" href="15476925512340.html">2018总结</a></li>
          
            <li><a title="关于HTTPS的探究" href="15221395300202.html">关于HTTPS的探究</a></li>
          
            <li><a title="灵活扩展的下拉刷新控件的封装" href="15113233292599.html">灵活扩展的下拉刷新控件的封装</a></li>
          
            <li><a title="从学习RunLoop到研究线程中同步和异步的关系" href="15035372165055.html">从学习RunLoop到研究线程中同步和异步的关系</a></li>
          
            <li><a title="对Swift写时复制技术的理解" href="15034498083541.html">对Swift写时复制技术的理解</a></li>
          
            <li><a title="从切圆角引发的对iOS动画框架的探究" href="15026719129123.html">从切圆角引发的对iOS动画框架的探究</a></li>
          
            <li><a title="基于Alamofire网络库的二次封装" href="15017218903153.html">基于Alamofire网络库的二次封装</a></li>
          
            <li><a title="Swift中对于有先后顺序的网络请求的优化" href="15008764200399.html">Swift中对于有先后顺序的网络请求的优化</a></li>
          
            <li><a title="Whats-new-in-swift-4 (上)" href="14969065461458.html">Whats-new-in-swift-4 (上)</a></li>
          
            <li><a title="Swift中对UserDefaults的封装" href="14956811508929.html">Swift中对UserDefaults的封装</a></li>
          
            <li><a title="Swift的一种常用类型" href="14936931972013.html">Swift的一种常用类型</a></li>
          
            <li><a title="按钮加下拉弹框控件的封装" href="14924176125873.html">按钮加下拉弹框控件的封装</a></li>
          

      
        <li class="divider"></li>
        <li><label>数据结构</label></li>

          
            <li><a title="Hash表" href="16377537990965.html">Hash表</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>Swift</span></li>
                        
                          <li><a title="从UTF-8到Bytes数组都经历了什么" href="16164841975946.html">从UTF-8到Bytes数组都经历了什么</a></li>
                        
                          <li><a title="由一个"Bug"引发的对Swift中Hashable，Equatable原理的探究" href="15972361312490.html">由一个"Bug"引发的对Swift中Hashable，Equatable原理的探究</a></li>
                        
                          <li><a title="学习SwiftUI两周之后" href="15611299445693.html">学习SwiftUI两周之后</a></li>
                        
                          <li><a title="沙漏动画" href="15367255656449.html">沙漏动画</a></li>
                        
                          <li><a title="2018总结" href="15476925512340.html">2018总结</a></li>
                        
                          <li><a title="关于HTTPS的探究" href="15221395300202.html">关于HTTPS的探究</a></li>
                        
                          <li><a title="灵活扩展的下拉刷新控件的封装" href="15113233292599.html">灵活扩展的下拉刷新控件的封装</a></li>
                        
                          <li><a title="从学习RunLoop到研究线程中同步和异步的关系" href="15035372165055.html">从学习RunLoop到研究线程中同步和异步的关系</a></li>
                        
                          <li><a title="对Swift写时复制技术的理解" href="15034498083541.html">对Swift写时复制技术的理解</a></li>
                        
                          <li><a title="从切圆角引发的对iOS动画框架的探究" href="15026719129123.html">从切圆角引发的对iOS动画框架的探究</a></li>
                        
                          <li><a title="基于Alamofire网络库的二次封装" href="15017218903153.html">基于Alamofire网络库的二次封装</a></li>
                        
                          <li><a title="Swift中对于有先后顺序的网络请求的优化" href="15008764200399.html">Swift中对于有先后顺序的网络请求的优化</a></li>
                        
                          <li><a title="Whats-new-in-swift-4 (上)" href="14969065461458.html">Whats-new-in-swift-4 (上)</a></li>
                        
                          <li><a title="Swift中对UserDefaults的封装" href="14956811508929.html">Swift中对UserDefaults的封装</a></li>
                        
                          <li><a title="Swift的一种常用类型" href="14936931972013.html">Swift的一种常用类型</a></li>
                        
                          <li><a title="按钮加下拉弹框控件的封装" href="14924176125873.html">按钮加下拉弹框控件的封装</a></li>
                        

                    
                      <li class="side-title"><span>数据结构</span></li>
                        
                          <li><a title="Hash表" href="16377537990965.html">Hash表</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 


	
		<div class="markdown-body">
		<h1>Hash表</h1>

		<h3 id="toc_0">什么是Hash</h3>

<p>散列函数（英语：Hash function）又称散列算法、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。[1]好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。<br/>
<a href="https://zh.wikipedia.org/wiki/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B8">维基百科</a></p>

<p>我的理解它是一种“标签”，可以将任意“毫无规律”的数据转义为长度固定的，格式固定的数据。</p>

<h3 id="toc_1">Hash表</h3>

<p>理想的情况是希望不经过任何比较，一次存取便能得到所查记录，那就必须在记录的存储位置和它的关键字之间建立一个确定的对应关系 f,使每个关键字和结构中一个唯一的存储位置相对应。因而在查找时，只要根据这个对应关系f，找到给定值k 的像f(K）。若结构中存在关键宇和区相等的记录,则必定在f(K)的存储位置上，由此，不需要进行比较便可直接取得所查记录。在此,我们称这个对应关系子为哈希（Hash）函数，按这个思想建立的表为哈希表。</p>

<h5 id="toc_2">优缺点</h5>

<p>优点其实很明显，就是它是根据key做<code>Hash</code>之后决定的存储位置，和数组对比，再读取某个<code>value</code>的时候，不需要遍历，可以直接再<code>Hash</code>，计算出地址，取出数据。在读取数据的时候将速度做好了极致。同时缺点也很明显，由于它的数据存储位置是通过<code>Hash</code>函数和<code>key</code>决定的,所以它是无序了，在对数据有顺序要求的情况下，缺点就暴露出来了。比如存日期，1号一定要在2号前面，但在实际的<code>Hash</code>表中，可能2号的内存地更靠前。</p>

<h3 id="toc_3">如何实现一个<code>Hash</code>表</h3>

<h5 id="toc_4">1. Hash函数</h5>

<p>第一步当然是构造一个<code>Hash</code>函数，其实一个好的（作用域广，碰撞少）哈希函数是非常困难的，当然这也不属于一个工科领域的问题，更偏向于理科（离散领域）。不过想要写一个简单的<code>Hash</code>函数还是很坚定的.<br/>
比如：<br/>
1) 直接地址法（取关键字或关键字的某个线性函数值作为地址）<br/>
H(key) = a * key + b<br/>
初中就学过的函数<br/>
比如有一个解放后出生人数的调查表。那我们的<code>Hash</code>函数完全可以是 H（key） = key + （-1948）<br/>
那key = 1949 ...,映射出的地址是1，2，3...，此种方法不会发生冲突，但这种方法的缺点就是对key有严格的要求，非常的不通用，所以实际也很少使用。</p>

<p>2）数字分析法:如果关键字由多位字符或者数字组成，就可以考虑抽取其中的 2 位或者多位作为该关键字对应的哈希地址，在取法上尽量选择变化较多的位，避免冲突发生。</p>

<p>例如表 2 中列举的是一部分关键字，每个关键字都是有 8 位十进制数组成：</p>

<p><img src="media/16377537990965/10420223S-1.png" alt="10420223S-1"/></p>

<p>表 2</p>

<p>通过分析关键字的构成，很明显可以看到关键字的第 1 位和第 2 位都是固定不变的，而第 3 位不是数字 3 就是 4，最后一位只可能取 2、7 和 5，只有中间的 4 位其取值近似随机，所以为了避免冲突，可以从 4 位中任意选取 2 位作为其哈希地址。</p>

<p>当然方法还有很多，比如 平方取中法，折叠法，除留余数法，随机数法，就不一一列举，实际的成熟的<code>Hash</code>算法，都比这要复杂很多。</p>

<h5 id="toc_5">2.Hash冲突</h5>

<p>上面我们提到的Hash算法中，都不可避免的遇到一种情况，就是不同的Key但<code>Hash</code>之后的值相同。所以我们必须要处理这种冲突，主要有两种方式，在我之前的「由一个bug引发的对Swift中Hashable，Equatable原理的探究」中有将，我将它复制过来，在多讲一些。</p>

<ul>
<li><p>链地址法：<br/>
链表地址法是使用一个链表数组，来存储相应数据，当hash遇到冲突的时候依次添加到链表的后面进行处理。<br/>
<img src="media/15972361312490/v2-976fe3afe0d50dbafa97ae47f6f6a53b_720w.png" alt="v2-976fe3afe0d50dbafa97ae47f6f6a53b_720"/><br/>
链地址在处理的流程如下：添加一个元素的时候，首先计算元素key的hash值，确定插入数组中的位置。如果当前位置下没有重复数据，则直接添加到当前位置。当遇到冲突的时候，添加到同一个<code>Hash</code>值的元素后面，行成一个链表。这个链表的特点是同一个链表上<code>Hash</code>Hash值相同。</p></li>
<li><p>开放地址法：<br/>
开放地址法是指大小为 M 的数组保存 N 个键值对，其中 M &gt; N。我们需要依靠数组中的空位解决碰撞冲突。基于这种策略的所有方法被统称为“开放地址”哈希表。线性探测法，就是比较常用的一种“开放地址”哈希表的一种实现方式。线性探测法的核心思想是当冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。简单来说就是：一旦发生冲突，就去寻找下 一个空的散列表地址，只要散列表足够大，空的散列地址总能找到。</p>

<p>假设散列长为8，散列函数H(K)=K mod 7，给定的关键字序列为{32,14,23,2, 20}当使用链表法时，相应<br/>
的数据结构如下图所示：<br/>
<img src="media/15972361312490/v2-dabac86f74bb61605f93258a01917590_720w.png" alt="v2-dabac86f74bb61605f93258a01917590_720"/><br/>
当使用线性探测法时，相应的数据结果如下图所示：<br/>
<img src="media/15972361312490/v2-cf46c1e0d22be22882ebc1974ae3c2cf_720w.png" alt="v2-cf46c1e0d22be22882ebc1974ae3c2cf_720"/><br/>
这里的两种算法的区别是2这个元素，在链表法中还是在节点2的位置上，但是在线性探测法遇到冲突时会将冲突数据放到下一个空的位置下面。<br/>
<a href="https://www.zhihu.com/question/26762707">对于两种方法的解释来自知乎的这个回答</a></p></li>
</ul>

<p>线性探测法又分有好几种，上面说的是线性探测再散列，也就是d = 1，2，3，意思就是依次寻找下一个地址，还有二次探测再散列，d = 1²，-1²，2²，-2²，3²，-3²，其实就是在当前地址+ 1 -1 + 4 -4,目的就是其实在处理一个由于冲突引起的问题，我们叫它「二次聚集」，顾名思义，就是由于冲突发生的位置比较固定，次数又多，咱这个位置地址就会被填的很慢，也总会发生冲突，比如 一次冲突后，将数据填到了8的位置，那下一次<code>Hash</code>值“真的”是8的也会冲突。<br/>
当然还有再Hash法，就是遇到冲突的时候用另一个<code>Hash</code>函数，取求一个地址，存入。公共溢出区法等等。但<code>Hash</code>冲突是无法彻底解决的，一个冲突低的<code>Hash</code>算法是衡量它是否足够优秀的重要标准。</p>

<blockquote>
<p>现代语言的<code>Hash</code>算法为了通用，一般计算出的值都比较复杂，不能直接映射成地址，所以这中间还需要一个简单的算法去映射一下，比如取中间的某几个值，或者取余，都ok的</p>
</blockquote>

<h3 id="toc_6">Hash表的查找</h3>

<p>在<code>Hash</code>表上进行查找的过程和<code>Hash</code>造表的过程基本一致。给定 K值，根据造表时设定的<code>Hash</code>函数求得哈希地址，若表中此位置上没有记录,则在找不成功;否则比较关键字，若和给定值相等，则查找成功;否则根据造表时设定的处理沖突的方法找“下一地址”,直至<code>Hash</code>表中某个位置为“空”或者表中所填记录的关键字等于给定值时为止。</p>

<h3 id="toc_7">Hash表的扩容</h3>

<p><code>Hash</code>表的初次开辟的地址都是有限的，即便是用了链表法，那在冲突多了之后，<code>Hash</code>表的效率也会变低，基本和遍历数组区别不大了。所以在在存储到了一定程度后，就需要扩容。那什么时候需要扩容，由负载因子决定，一般是0.75，比如在100个连续的地址，当有75个存有数据后，就需要进行扩容，目的是降低冲突，提高效率。扩容时，需要将原来的数据再用新的<code>Hash</code>函数在映射一次，使其“均匀”的存入扩容后的地址空间中。</p>


		</div>
	

  
  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    


  </body>
</html>
